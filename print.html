<!DOCTYPE HTML>
<html lang="zh-Hans-CN" class="light" dir="ltr">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>推箱子教程</title>
    <meta name="robots" content="noindex">


    <!-- Custom HTML head -->
    
    <meta name="description" content="本文将描述如何实现一个推箱子 📦, 示例代码使用 Rust 语言 🦀 编写.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff">

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->

</head>

<body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">介绍</a></li><li class="chapter-item expanded "><a href="level/index.html"><strong aria-hidden="true">1.</strong> 关卡</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="level/representation.html"><strong aria-hidden="true">1.1.</strong> 表示</a></li><li class="chapter-item expanded "><a href="level/construction.html"><strong aria-hidden="true">1.2.</strong> 构造</a></li><li class="chapter-item expanded "><a href="level/normalization.html"><strong aria-hidden="true">1.3.</strong> 标准化 🚧</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 动作</div></li><li class="chapter-item expanded "><a href="solver/index.html"><strong aria-hidden="true">3.</strong> 求解器 🚧</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="solver/solving_strategy.html"><strong aria-hidden="true">3.1.</strong> 搜索策略 🚧</a></li><li class="chapter-item expanded "><a href="solver/heuristic_function.html"><strong aria-hidden="true">3.2.</strong> 启发式函数 🚧</a></li><li class="chapter-item expanded "><a href="solver/optimization.html"><strong aria-hidden="true">3.3.</strong> 优化</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.1.</strong> 割点</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.2.</strong> 隧道</div></li><li class="chapter-item expanded "><a href="solver/deadlocks.html"><strong aria-hidden="true">3.3.3.</strong> 死锁 🚧</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> 双向搜索</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 优化器</div></li><li class="chapter-item expanded "><a href="resources.html"><strong aria-hidden="true">5.</strong> 资源 🚧</a></li><li class="chapter-item expanded "><a href="glossary_of_terms.html"><strong aria-hidden="true">6.</strong> 术语表 🚧</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function (e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor"
                            title="Toggle Table of Contents" aria-label="Toggle Table of Contents"
                            aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">推箱子教程</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ShenMian/sokoban-tutorial" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>本文将描述如何实现一个推箱子 📦, 示例代码使用 Rust 语言 🦀 编写.</p>
<h2 id="推箱子的起源"><a class="header" href="#推箱子的起源">推箱子的起源</a></h2>
<p>推箱子在 1981 年由日本人今林宏行(いまばやし ひろゆき)所创造, 第一个版本于 1982 年 12 月发行, 名为<em>仓库番</em>, 字面意思为 "仓库管理员" 👷.<sup class="footnote-reference"><a href="#1">1</a></sup> 英文名为: Sokoban 或 Soukoban.</p>
<p><img src="assets/first_sokoban_15.png" alt="First Sokoban #15" /></p>
<p>截至 2024 年, 最新版本推箱子(みんなの倉庫番)于 2019 年 8 月发行于 PlayStation 4 平台.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p><img src="assets/everyones_sokoban.jpg" alt="The Sokoban" /></p>
<p>最新版本的推箱在角色控制方面相较于其最初的版本并未见明显改进, 本文后续将介绍一种纯鼠标控制的角色控制方法 🖱️.</p>
<h2 id="为什么通过案例来讲解"><a class="header" href="#为什么通过案例来讲解">为什么通过案例来讲解</a></h2>
<p>本文以推箱子为案例, 深入浅出的描述软件开发过程. 通过案例讲解有以下目的:</p>
<ul>
<li>结合实例的学习可以将<strong>知识</strong>和<strong>应用</strong>结合在一起, 使读者无需被 "学这个有什么用?" 所困扰 🤔.</li>
<li>提供丰富的实例. 推箱子问题本身还附带了许多子问题, 很适合作为例子使用.</li>
<li>众多读者对游戏有浓厚的兴趣 🎮.</li>
</ul>
<h2 id="为什么选择推箱子作为案例"><a class="header" href="#为什么选择推箱子作为案例">为什么选择推箱子作为案例</a></h2>
<p>之所以选择推箱子, 是因为它具有以下特点:</p>
<ul>
<li><strong>规则简单</strong>: 可以专注于实现功能, 而非理解复杂的游戏规则和机制.</li>
<li><strong>基本功能易于实现</strong>: 如推箱子和通关判断.</li>
<li><strong>有具有挑战的高级功能</strong>: 如纯鼠标控制, 逆推等.</li>
<li><strong>有需要深入钻研的求解器</strong>: 用于自动求解推箱子关卡.</li>
</ul>
<p>推箱子的实现<strong>既可以简单也可以复杂</strong>, 读者可以根据自身的情况选择学习的深度.</p>
<h2 id="需要具备的知识"><a class="header" href="#需要具备的知识">需要具备的知识</a></h2>
<ul>
<li>具备 Rust 语言的语法基础, 或熟悉一门编程语言.</li>
<li>有关高级功能和求解器的章节: 具备数据结构与算法的基础知识, 如 A* 搜索算法的工作原理.</li>
</ul>
<h2 id="内容范围"><a class="header" href="#内容范围">内容范围</a></h2>
<p>本文将描述基本功能的具体实现方法, 高级功能的实现方法以及求解器的实现思路.<br />
但本文<strong>不涉及</strong>以下内容:</p>
<ul>
<li>Rust 语言本身: 本文中出现的算法适用于其他编程语言, 但依然会涉及部分 Rust 相关内容的讲解, 如错误处理 (Rust 在这方面和其他语言不太一样), 不感兴趣的读者可以直接跳过这部分内容.</li>
<li>游戏引擎: 本文中的推箱子实现并不依赖游戏引擎, 比如有的推箱子实现需要用到射线检测.</li>
<li>推箱子的其他变体(Variant)<sup class="footnote-reference"><a href="#2">2</a></sup>.</li>
</ul>
<h2 id="项目代码"><a class="header" href="#项目代码">项目代码</a></h2>
<p>完整的项目代码位于:</p>
<ul>
<li><a href="https://github.com/shenmian/soukoban">ShenMian/soukoban</a>: 推箱子相关算法实现.</li>
<li><a href="https://github.com/shenmian/sokoban-rs">ShenMian/sokoban-rs</a>: 推箱子实现, 使用 Bevy 引擎.</li>
</ul>
<h2 id="拓展资料"><a class="header" href="#拓展资料">拓展资料</a></h2>
<p>推荐视频 🎥:</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Ph41117YT">【GM】火遍全球的推箱子，那些你所不知道的故事！· Bilibili</a>: 该视频详细介绍了推箱子的历史和发展.</li>
</ul>
<h2 id="版权"><a class="header" href="#版权">版权</a></h2>
<p>本文遵循 <a href="https://creativecommons.org/licenses/by/4.0/">CC-BY 4.0</a> 协议发布. 部分图片来源于互联网, 版权归原作者所有.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.sokoban.jp/history.html">https://www.sokoban.jp/history.html</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="https://en.wikipedia.org/wiki/Sokoban#Variants">https://en.wikipedia.org/wiki/Sokoban#Variants</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="关卡"><a class="header" href="#关卡">关卡</a></h1>
<h2 id="xsb-格式"><a class="header" href="#xsb-格式">XSB 格式</a></h2>
<p>推箱子关卡所使用的 XSB 格式因其简洁和直观而受到了广泛的认可和应用, 最初由 XSokoban 所使用. 该格式使用 ASCII 字符来表示地图元素, 并支持注释和附加元数据.<br />
以关卡 <code>Boxworld #1</code> 为例:</p>
<p><img src="level/../assets/boxworld_1.png" alt="Boxworld #1" /></p>
<p>其 XSB 格式关卡的数据如下:</p>
<pre><code class="language-txt">;Level 1
__###___
__#.#___
__#-####
###$-$.#
#.-$@###
####$#__
___#.#__
___###__
Title: Boxworld 1
Author: Thinking Rabbit
</code></pre>
<p>上面的关卡数据大致可分为以下几种:</p>
<ul>
<li>第 1 行, 单行注释, 以 <code>;</code> 开头.</li>
<li>第 2-9 行, 地图数据, 使用 ASCII 字符表示.</li>
<li>第 10-11 行, 元数据, 包括关卡标题和作者的信息.</li>
</ul>
<h3 id="地图数据"><a class="header" href="#地图数据">地图数据</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ASCII 符号</th><th>描述</th></tr></thead><tbody>
<tr><td><code>&lt;SPACE&gt;</code>/<code>-</code>/<code>_</code></td><td>地板</td></tr>
<tr><td><code>#</code></td><td>墙体 🧱</td></tr>
<tr><td><code>$</code></td><td>箱子 📦</td></tr>
<tr><td><code>.</code></td><td>目标 🎯</td></tr>
<tr><td><code>@</code></td><td>玩家 👷</td></tr>
<tr><td><code>+</code></td><td>位于目标上的玩家</td></tr>
<tr><td><code>*</code></td><td>位于目标上的箱子</td></tr>
</tbody></table>
</div>
<p>其中地板一共使用了三种符号表示, 是因为连续的空格在某些在线论坛或邮件中可能被截断, 因此使用连字符(<code>-</code>)和下划线(<code>_</code>)来替代.</p>
<h3 id="元数据"><a class="header" href="#元数据">元数据</a></h3>
<p>第 10 行的 <code>Title: Boxworld 1</code> 可以解释为键为 <code>title</code> (不区分大小写), 值为 <code>Boxworld 1</code> 的元数据.<br />
还有一种用于多行注释的特殊元数据. 内容通过 <code>comment:</code> 和 <code>comment-end:</code> 包裹. 这也是唯一支持值有多行的元数据.</p>
<p>!!! info
多行注释还存在一种以 <code>comment:</code> 和 <code>comment_end:</code> 包裹的写法, 与之前提到的多行注释不同，这种多行注释使用下划线(<code>_</code>)来替代连字符(<code>-</code>)分割单词.<br />
本文将这种格式视为<strong>无效格式</strong>, 其可能是在批量替换 <code>_</code> 和 <code>-</code> 字符时意外产生的.</p>
<h2 id="游程编码-"><a class="header" href="#游程编码-">游程编码 🗜️</a></h2>
<p>游程编码(Run-length encoding, RLE)是无损数据压缩的一种形式, 常被应用于推箱子关卡和解决方案的压缩.</p>
<pre><code class="language-txt">###
#.###
#*$ #
# @ #
#####
</code></pre>
<p>经 RLE 编码后可得:</p>
<pre><code class="language-txt">3#
#.3#
#*$-#
#--@#
5#
</code></pre>
<p>可以看出, 虽然编码后的关卡有更小的体积, 但不再能直观地看出关卡的结构.</p>
<p>RLE 编码后的关卡通常还会使用 <code>|</code> 来分割行, 而非 <code>\n</code>. 使其看上去更加紧凑:</p>
<pre><code class="language-txt">3#|#.3#|#*$-#|#--@#|5#
</code></pre>
<p>只需要对原本的语句进行修改即可提供对 <code>|</code> 分割行的支持:</p>
<pre><code class="language-rs">for line in str.lines() { ... SKIP ... }

for line in str.split(['\n', '|']) { ... SKIP ... }
</code></pre>
<h3 id="编码"><a class="header" href="#编码">编码</a></h3>
<p>下面是一个简单的 RLE 编码函数的实现:</p>
<pre><code class="language-rs">pub fn rle_encode(str: &amp;str) -&gt; Result&lt;String, EncodeRleError&gt; {
    let mut result = String::new();
    let mut chars = str.chars().peekable();
    let mut count = 0;
    while let Some(char) = chars.next() {
        if char.is_numeric() {
            return Err(EncodeRleError::InvalidCharacter(char));
        }
        count += 1;
        if chars.peek() != Some(&amp;char) {
            if count &gt; 1 {
                result.push_str(&amp;count.to_string());
            }
            result.push(char);
            count = 0;
        }
    }
    Ok(result)
}
</code></pre>
<p>该方法不会使用括号包裹重复的相连子串以提高压缩率.</p>
<h3 id="解码"><a class="header" href="#解码">解码</a></h3>
<p>下面是一个 RLE 解码函数的实现:</p>
<pre><code class="language-rs">pub fn rle_decode(str: &amp;str) -&gt; Result&lt;String, DecodeRleError&gt; {
    let mut result = String::new();

    let mut length_string = String::new();
    let mut iter = str.chars();
    while let Some(char) = iter.next() {
        if char.is_ascii_digit() {
            length_string.push(char);
            continue;
        }
        let mut token = String::new();
        if char == '(' {
            let mut nesting_level = 0;
            for char in &amp;mut iter {
                if char == '(' {
                    nesting_level += 1;
                } else if char == ')' {
                    if nesting_level == 0 {
                        break;
                    }
                    nesting_level -= 1;
                }
                token.push(char);
            }
        } else {
            token = char.to_string();
        }
        let length = length_string.parse().unwrap_or(1);
        result += &amp;token.repeat(length);
        length_string.clear();
    }
    if !length_string.is_empty() {
        return Err(DecodeRleError::EndWithDigits(
            length_string.parse().unwrap(),
        ));
    }
    if result.contains('(') {
        return rle_decode(&amp;result);
    }
    Ok(result)
}
</code></pre>
<h2 id="其他格式"><a class="header" href="#其他格式">其他格式</a></h2>
<h3 id="sok"><a class="header" href="#sok">Sok</a></h3>
<p>推箱子程序 Sokoban YASC 专用格式, 兼容 XSB 格式:</p>
<pre><code class="language-txt">Boxworld 1

__###___
__#.#___
__#-####
###b-b.#
#.-bp###
####b#__
___#.#__
___###__

Author: Thinking Rabbit
</code></pre>
<p>请参见 <a href="http://sokobano.de/wiki/index.php?title=Sok_format">Sok format · Sokoban Wiki</a>.</p>
<h3 id="mf8"><a class="header" href="#mf8">MF8</a></h3>
<p>中文论坛魔方吧<sup class="footnote-reference"><a href="#1">1</a></sup>使用 MF8 格式:</p>
<pre><code class="language-txt">[soko=8,8]
__HHH___
__H.H___
__H_HHHH
HHH$_$.H
H._$aHHH
HHHH$H__
___H.H__
___HHH__
[/soko]
</code></pre>
<h2 id="特殊关卡"><a class="header" href="#特殊关卡">特殊关卡</a></h2>
<h3 id="玩家不可达区域存在箱子"><a class="header" href="#玩家不可达区域存在箱子">玩家不可达区域存在箱子</a></h3>
<p><img src="level/../assets/sasquatch_41.png" alt="Sasquatch #41 by David W. Skinner" /></p>
<pre><code class="language-txt">   #####
   #   #
 ###   ########
##  ***    # # #
 #  * *    ## # #####
##  ***   ## # ##   ##
 ###   #### # # #   #
   #   # # # ####$ $###
  ##   ## # ##  $...$ ##
   ##### # ##    .@.  #
        # # #   $...$ ##
         ########$ $###
                #   #
                #####
</code></pre>
<h3 id="存在只有空元素的行"><a class="header" href="#存在只有空元素的行">存在只有空元素的行</a></h3>
<p><img src="level/../assets/steaming_hot.png" alt="&quot;Steaming Hot&quot; by David Buchweitz" /></p>
<pre><code class="language-txt">  #      #
 #   #  #
  # #  #
   # #  #
  #   #  #
 #   #  #
  # #  #
-
##########
#........####
# $$$$$$$#  #
#.$......#  #
# $$$$$$ #  #
#......$+#  #
#$$$$$$$ #  #
#        ####
##########
</code></pre>
<h3 id="无完整外墙"><a class="header" href="#无完整外墙">无完整外墙</a></h3>
<p>部分推箱子程序支持无完整外墙的关卡.<br />
在本文中, 这种关卡属于无效关卡. 但可以通过为其添加外墙的方式来转换为有效关卡.</p>
<p><img src="level/../assets/no_walls_level.png" alt="&quot;No walls&quot; by Rincewind" /></p>
<pre><code class="language-txt">* ** *
  **
**@$.*
  **
* ** *
</code></pre>
<h2 id="拓展资料-1"><a class="header" href="#拓展资料-1">拓展资料</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Run-length_encoding">https://en.wikipedia.org/wiki/Run-length_encoding</a>.</li>
</ul>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="http://sokobano.de/wiki/index.php?title=Level_format">http://sokobano.de/wiki/index.php?title=Level_format</a>.</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="http://www.mf8-china.com/forum.php">http://www.mf8-china.com/forum.php</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="表示"><a class="header" href="#表示">表示</a></h1>
<h2 id="表示地图-"><a class="header" href="#表示地图-">表示地图 🗺️</a></h2>
<h3 id="元素的表示"><a class="header" href="#元素的表示">元素的表示</a></h3>
<p>地图共包含 5 种元素, 这些元素可能在一个格子内叠加(比如玩家位于目标上).<br />
最小的数据存储单元字节包含 8 个比特, 足以表示 5 种元素. 因此可以使用一个字节的空间来存储单个地图格子, 其中的每个比特表示一种地图元素.<br />
创建用于表示地图元素的比特位:</p>
<pre><code class="language-rs">use bitflags::bitflags;

bitflags! {
    pub struct Tiles: u8 {
        const Floor = 1 &lt;&lt; 0;
        const Wall = 1 &lt;&lt; 1;
        const Box = 1 &lt;&lt; 2;
        const Goal = 1 &lt;&lt; 3;
        const Player = 1 &lt;&lt; 4;
    }
}
</code></pre>
<p>这样可以很方便的表示多种地图元素叠加的情况, 如使用 <code>Tiles::Floor | Tiles::Goal | Tiles::Player</code> 来表示玩家位于目标上, 而目标位于地板上的情况.<br />
利用比特位表示元素不仅使得判断元素是否存在、添加或移除某个元素等操作变得非常便捷, 而且还有位运算带来的性能上的优势.</p>
<h3 id="地图的存储"><a class="header" href="#地图的存储">地图的存储</a></h3>
<p>使用一维数组来存储地图数据, 使用二维向量(数学)存储地图尺寸.</p>
<pre><code class="language-rs">use nalgebra::Vector2;

pub struct Map {
    data: Vec&lt;Tiles&gt;,
    dimensions: Vector2&lt;i32&gt;,
    // ... SKIP ...
}
</code></pre>
<p>这样设计有以下考量:</p>
<ol>
<li>与拥有固定尺寸棋盘的棋类游戏不同, 推箱子关卡的尺寸是可变的, 因此使用动态数组.</li>
<li>使用一维数组而非二维数组 <code>Vec&lt;Vec&lt;Tiles&gt;&gt;</code> 是因为一维数组更平坦(flatten), 能确保动态数组的元素在内存中是紧密排列的, 根据数据局部性原理, 这通常能提高内存读取效率. 此外, 由于结构更为简单, 使得部分操作的代码更为简洁高效, 比如调整地图尺寸.</li>
</ol>
<p>但这也意味着通过二维坐标访问地图元素需要手动计算一维数组中对应的下标, 可以通过以下方式实现:</p>
<pre><code class="language-rs">impl Index&lt;Vector2&lt;i32&gt;&gt; for Map {
    type Output = Tiles;

    fn index(&amp;self, position: Vector2&lt;i32&gt;) -&gt; &amp;Tiles {
        assert!(0 &lt;= position.x &amp;&amp; position.x &lt; self.dimensions.x &amp;&amp; 0 &lt;= position.y);
        &amp;self.data[(position.y * self.dimensions.x + position.x) as usize]
    }
}

impl IndexMut&lt;Vector2&lt;i32&gt;&gt; for Map {
    fn index_mut(&amp;mut self, position: Vector2&lt;i32&gt;) -&gt; &amp;mut Tiles {
        assert!(0 &lt;= position.x &amp;&amp; position.x &lt; self.dimensions.x &amp;&amp; 0 &lt;= position.y);
        &amp;mut self.data[(position.y * self.dimensions.x + position.x) as usize]
    }
}
</code></pre>
<p>这样便可以直接通过二维坐标访问地图元素, 例如访问地图 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 位置的元素: <code>map[Vector2::new(1, 1)]</code>.<br />
这样的设计不仅可以享受了二维数组访问方式的便捷性, 还能保留了一维数组带来的性能优势.</p>
<p>值得注意的是其中的断言, 该函数最终通过下标访问一维数组由 <code>Index&lt;&gt; for Vec&lt;&gt;</code> 进行了部分越界检查, 但越界检查依然不完整, 没有涵盖以下无效情况:</p>
<ol>
<li>坐标 <code>x</code> 可以超出地图宽度的情况, 但其一维数组下标依然有效.</li>
<li>坐标 <code>x</code>, <code>y</code> 中存在负数, 但其一维数组下标依然可能是正数.</li>
</ol>
<h2 id="表示关卡"><a class="header" href="#表示关卡">表示关卡</a></h2>
<p>关卡数据可分为三个部分: 地图数据, 元数据和注释. 其中注释可以作为元数据.<br />
元数据是一个键值对的集合, 且键不重复, 因此可以使用 <code>HashMap</code> 容器来存储.
可以使用下面的结构体存储关卡数据:</p>
<pre><code class="language-rs">use std::collections::HashMap;

pub struct Level {
    map: Map,
    metadata: HashMap&lt;String, String&gt;,
    // ... SKIP ...
}
</code></pre>
<p>将地图从关卡中拆分是因为地图涉及大量的关联函数, 如果都放在 <code>Level</code> 里会导致其变得过于庞大.<br />
为了提升代码的可读性和可维护性, 将相关代码拆分到 <code>Map</code> 中, 并通过实现 <code>Deref</code> trait, 使得用户能够透明地引用到 <code>Level</code> 内部的 <code>Map</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="构造-"><a class="header" href="#构造-">构造 🏗️</a></h1>
<h2 id="从-xsb-格式字符串构造关卡"><a class="header" href="#从-xsb-格式字符串构造关卡">从 XSB 格式字符串构造关卡</a></h2>
<p>关卡解析可以分为两部分: 地图解析, 元数据和注释解析.</p>
<p>一个 XSB 格式的关卡文件中通常包含多个关卡, 不同关卡之间通过空行分割. 因此解析 XSB 格式的数据大致可分为两个步骤:</p>
<ol>
<li>多个关卡之间的分割.</li>
<li>单个关卡的解析.</li>
</ol>
<pre class="mermaid">flowchart LR
    A[包含多个关卡的字符串] --&gt;|Level::to_group| B
    B[包含单个关卡的字符串] --&gt; C{是否经过\n RLE 压缩?}
    C --&gt;|是| D[RLE 压缩字符串]
    C --&gt;|否| E
    D --&gt;|rle_decode| E
    E[非 RLE 压缩字符串]
</pre>
<h3 id="多个关卡之间的分割"><a class="header" href="#多个关卡之间的分割">多个关卡之间的分割</a></h3>
<p>定义关联函数 <code>Level::to_groups</code>, 接受包含多个关卡的字符串, 返回包含单个关卡的字符串切片的迭代器.</p>
<pre><code class="language-rs">impl Level {
    // ... SKIP ...

    fn to_groups(str: &amp;str) -&gt; impl Iterator&lt;Item = &amp;str&gt; + '_ {
        str.split(['\n', '|']).filter_map({
            let mut offset = 0;
            let mut len = 0;
            let mut in_block_comment = false;
            let mut has_map_data = false;
            move |line| {
                len += line.len() + 1;

                let trimmed_line = line.trim();
                if !in_block_comment &amp;&amp; (trimmed_line.is_empty() || offset + len == str.len() + 1) {
                    let group = &amp;str[offset..offset + len - 1];
                    offset += len;
                    len = 0;
                    if group.is_empty() || !has_map_data {
                        return None;
                    }
                    has_map_data = false;
                    Some(group)
                } else {
                    if in_block_comment {
                        if trimmed_line.to_lowercase().starts_with("comment-end") {
                            // Exit block comment
                            in_block_comment = false;
                        }
                        return None;
                    }
                    if let Some(value) = trimmed_line.to_lowercase().strip_prefix("comment:") {
                        if value.trim_start().is_empty() {
                            // Enter block comment
                            in_block_comment = true;
                        }
                        return None;
                    }
                    if has_map_data || !is_xsb_string(trimmed_line) {
                        return None;
                    }

                    has_map_data = true;

                    None
                }
            }
        })
    }
}
</code></pre>
<p>出于性能方面的考虑, 解析关卡数据时应该<strong>减少不必要的动态内存分配</strong>:</p>
<ul>
<li>由于函数 <code>Level::to_groups</code> 仅对输入字符串进行解析, 不涉及修改操作, 因此其参数类型为字符串切片 <code>&amp;str</code>, 类似 C++ 中的 <code>std::string_view</code>.</li>
<li>单个关卡的数据是连续的, 因此可以使用字符串切片来表示, 无需再使用 <code>String</code> 来存储地图数据.</li>
</ul>
<p>以上方法通过直接引用原始字符串避免了内存分配, 减少内存占用的同时提高了执行效率. 而且还使得对内存的访问更加局部化.</p>
<p>返回迭代器是因为可以利用迭代器的<strong>惰性求值</strong>, 来惰性的分割关卡.</p>
<p>这种实现方式有以下优点:</p>
<ul>
<li>支持流式读取并构造关卡. 例如, 通过利用 <code>BufReader</code><sup class="footnote-reference"><a href="#2">1</a></sup> 支持从大文件中逐步地加载关卡数据, 避免了内存的大量占用和性能瓶颈.</li>
<li>读取第 n 个关卡. 跳过前 n-1 个关卡, 只对第 n 个关卡的数据进行解析. 可以加快从多个关卡中加载单个关卡的速度.</li>
</ul>
<pre><code class="language-rs">impl Level {
    pub fn load(str: &amp;str) -&gt; impl Iterator&lt;Item = Result&lt;Self, ParseLevelError&gt;&gt; + '_ {
        Self::to_groups(str).map(Self::from_str)
    }

    pub fn load_nth(str: &amp;str, id: usize) -&gt; Result&lt;Self, ParseLevelError&gt; {
        let group = Self::to_groups(str).nth(id - 1).unwrap();
        Self::from_str(group)
    }
    
    // ... SKIP ...
}
</code></pre>
<p>这样便实现的关卡的惰性解析. 比如搜索完全一致的关卡:</p>
<pre><code class="language-rs">let str = "..."; // 海量关卡
for level in Level::load(&amp;fs::read_to_string(path).unwrap()).filter_map(|x| x.ok()) {
    // ... SKIP ...
}
</code></pre>
<p>若循环体在循环的过程中通过 <code>break</code> 语句提前退出循环, 未被循环到的关卡将不会被解析, 从而减少不必要的计算.</p>
<p>值得注意的是, 虽然在一些编程语言中 <code>Level::load_nth</code> 的实现是多余的, 但在 Rust 中, 迭代器先 <code>map</code> 后 <code>nth</code> 与先 <code>nth</code> 后 <code>map</code> 并<strong>不等价</strong>, 前者会执行 n 次 <code>map</code>, 而后者只会执行一次 <code>map</code>, 显著提高了效率.</p>
<h3 id="单个关卡的解析"><a class="header" href="#单个关卡的解析">单个关卡的解析</a></h3>
<h4 id="解析元数据和注释"><a class="header" href="#解析元数据和注释">解析元数据和注释</a></h4>
<p>定义一个关联函数 <code>Level::from_str</code>, 作为 <code>Level</code> 的构造函数. 该函数只负责解析关卡的元数据和注释, 地图数据的进一步解析则由 <code>Map::from_str</code> 负责:</p>
<pre><code class="language-rs">impl Level {
    pub fn from_str(str: &amp;str) -&gt; Result&lt;Self, ParseLevelError&gt; {
        // ... SKIP ...
        Ok(Self {
            map: Map::from_str(/* ... SKIP ... */)?,
            metadata,
            // ... SKIP ...
        })
    }
    // ... SKIP ...
}
</code></pre>
<p>关联函数 <code>Level::from_str</code> 需要将元数据存储到 <code>HashMap</code> 容器中, 同时提取地图数据后续交给 <code>Map::from_str</code> 做进一步解析.<br />
由于地图数据是连续的, 所以也可以使用字符串切片表示.</p>
<pre><code class="language-rs">impl Level {
    pub fn from_str(str: &amp;str) -&gt; Result&lt;Self, ParseLevelError&gt; {
        let mut map_offset = 0;
        let mut map_len = 0;
        let mut metadata = HashMap::new();
        let mut comments = String::new();
        let mut in_block_comment = false;
        for line in str.split_inclusive(['\n', '|']) {
            if map_len == 0 {
                map_offset += line.len();
            }

            let trimmed_line = line.trim();
            if trimmed_line.is_empty() {
                continue;
            }

            // Parse comments
            if in_block_comment {
                if trimmed_line.to_lowercase().starts_with("comment-end") {
                    // Exit block comment
                    in_block_comment = false;
                    continue;
                }
                comments += trimmed_line;
                comments.push('\n');
                continue;
            }
            if let Some(comment) = trimmed_line.strip_prefix(';') {
                comments += comment.trim_start();
                comments.push('\n');
                continue;
            }

            // Parse metadata
            if let Some((key, value)) = trimmed_line.split_once(':') {
                let key = key.trim().to_lowercase();
                let value = value.trim();

                if key == "comment" {
                    if value.is_empty() {
                        // Enter block comment
                        in_block_comment = true;
                    } else {
                        comments += value;
                        comments.push('\n');
                    }
                    continue;
                }

                if metadata.insert(key.clone(), value.to_string()).is_some() {
                    return Err(ParseLevelError::DuplicateMetadata(key));
                }
                continue;
            }

            // Discard line that are not map data (with RLE)
            if !is_xsb_string(trimmed_line) {
                if map_len != 0 {
                    return Err(ParseMapError::InvalidCharacter(
                        trimmed_line
                            .chars()
                            .find(|&amp;c| !is_xsb_symbol_with_rle(c))
                            .unwrap(),
                    )
                    .into());
                }
                continue;
            }

            if map_len == 0 {
                map_offset -= line.len();
            }
            map_len += line.len();
        }
        if !comments.is_empty() {
            debug_assert!(!metadata.contains_key("comments"));
            metadata.insert("comments".to_string(), comments);
        }
        if in_block_comment {
            return Err(ParseLevelError::UnterminatedBlockComment);
        }
        if map_len == 0 {
            return Err(ParseLevelError::NoMap);
        }

        Ok(Self {
            map: Map::from_str(&amp;str[map_offset..map_offset + map_len])?,
            metadata,
            // ... SKIP ...
        })
    }
    // ... SKIP ...
}
</code></pre>
<p>在处理过程中, 注释内容被特别识别, 并作为键为 <code>comments</code> 的元数据, 一同存储到 <code>Level::metadata</code> 中.</p>
<h4 id="解析地图数据"><a class="header" href="#解析地图数据">解析地图数据</a></h4>
<p>解析地图数据可以分为以下几个部分:</p>
<ol>
<li><strong>去除多余空白</strong>: 首先, 移除每行右侧的空白字符. 随后, 确定地图左侧的最小缩进量(即每行左侧空白字符的最小数量), 并据此剔除左侧的多余空白.</li>
<li><strong>确定地图尺寸</strong>: 与 MF8 格式不同, XSB 格式并不直接附带地图尺寸数据, 因此需要通过解析关卡地图数据来确定地图尺寸.</li>
<li><strong>RLE 解码</strong>: 如果地图数据经过 RLE 编码, 进行解码操作.</li>
<li><strong>解析地图数据</strong>: 地图数据使用 <code>Tiles</code> 表示, 写入缓冲区中.</li>
<li><strong>填充地板</strong>: 使用洪水填充算法从玩家位置开始, 以墙为边界填充地板.</li>
</ol>
<pre><code class="language-rs">impl Map {
    pub fn from_str(str: &amp;str) -&gt; Result&lt;Self, ParseMapError&gt; {
        debug_assert!(!str.trim().is_empty(), "string is empty");

        // Calculate map dimensions and indentation
        let mut indent = i32::MAX;
        let mut dimensions = Vector2::&lt;i32&gt;::zeros();
        let mut buffer = String::with_capacity(str.len());
        for line in str.split(['\n', '|']) {
            let mut line = line.trim_end().to_string();
            if line.is_empty() {
                continue;
            }
            // If the `line` contains digits, perform RLE decoding
            if line.chars().any(char::is_numeric) {
                line = rle_decode(&amp;line).unwrap();
            }
            dimensions.x = dimensions.x.max(line.len() as i32);
            dimensions.y += 1;
            indent = indent.min(line.chars().take_while(char::is_ascii_whitespace).count() as i32);
            buffer += &amp;(line + "\n");
        }
        dimensions.x -= indent;

        let mut instance = Map::with_dimensions(dimensions);

        // Parse map data
        let mut player_position: Option&lt;Vector2&lt;_&gt;&gt; = None;
        for (y, line) in buffer.lines().enumerate() {
            // Trim map indentation
            let line = &amp;line[indent as usize..];
            for (x, char) in line.chars().enumerate() {
                let position = Vector2::new(x as i32, y as i32);
                instance[position] = match char {
                    ' ' | '-' | '_' =&gt; Tiles::empty(),
                    '#' =&gt; Tiles::Wall,
                    '$' =&gt; {
                        instance.box_positions.insert(position);
                        Tiles::Box
                    }
                    '.' =&gt; {
                        instance.goal_positions.insert(position);
                        Tiles::Goal
                    }
                    '@' =&gt; {
                        if player_position.is_some() {
                            return Err(ParseMapError::MoreThanOnePlayer);
                        }
                        player_position = Some(position);
                        Tiles::Player
                    }
                    '*' =&gt; {
                        instance.box_positions.insert(position);
                        instance.goal_positions.insert(position);
                        Tiles::Box | Tiles::Goal
                    }
                    '+' =&gt; {
                        if player_position.is_some() {
                            return Err(ParseMapError::MoreThanOnePlayer);
                        }
                        player_position = Some(position);
                        instance.goal_positions.insert(position);
                        Tiles::Player | Tiles::Goal
                    }
                    _ =&gt; return Err(ParseMapError::InvalidCharacter(char)),
                };
            }
        }
        if instance.box_positions.len() != instance.goal_positions.len() {
            return Err(ParseMapError::BoxGoalMismatch);
        }
        if instance.box_positions.is_empty() {
            return Err(ParseMapError::NoBoxOrGoal);
        }
        if let Some(player_position) = player_position {
            instance.player_position = player_position;
        } else {
            return Err(ParseMapError::NoPlayer);
        }

        instance.add_floors(instance.player_position);

        Ok(instance)
    }
    // ... SKIP ...
}
</code></pre>
<p>其中部分<em>验证解决方案</em>步骤能发现的错误也可以在<em>模拟玩家移动</em>的步骤中提前发现, 但为了保持代码的简洁, 这里不做检查.</p>
<h4 id="性能测试"><a class="header" href="#性能测试">性能测试</a></h4>
<div class="table-wrapper"><table><thead><tr><th>项目</th><th>平均耗时</th></tr></thead><tbody>
<tr><td>加载 3371 个关卡</td><td>23.714 ms</td></tr>
<tr><td>加载第 3371 个关卡</td><td>3.2700 ms</td></tr>
</tbody></table>
</div>
<p>根据数据, 可以得出以下结论:</p>
<ol>
<li>加载单个关卡的平均耗时约 7 μs.</li>
<li>加载 n 个关卡和加载第 n 个关卡的耗时存在显著差异, 说明后者确实有性能的提升.</li>
</ol>
<h4 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h4>
<p>在解析地图数据的过程中, 应该关注可能发生的错误, 并进行相应的检查.<br />
幸运的是, 许多常见的错误都可以在解析数据的同时顺便进行排查, 这样只会带来极小的额外开销, 从而确保地图的正确性和完整性.</p>
<pre><code class="language-rs">#[derive(Error, Clone, Eq, PartialEq, Debug)]
pub enum ParseLevelError {
    // ... SKIP ...
}

#[derive(Error, Clone, Eq, PartialEq, Debug)]
pub enum ParseMapError {
    // ... SKIP ...
}

impl From&lt;ParseMapError&gt; for ParseLevelError {
    fn from(error: ParseMapError) -&gt; Self {
        ParseLevelError::ParseMapError(error)
    }
}
</code></pre>
<p>重载 <code>ParseMapError</code> 到 <code>ParseLevelError</code> 的转换, 以便 <code>Level::from_str</code> 直接返回 <code>Map::from_str</code> 中的错误.<br />
遵循 Rust API Guidelines (C-GOOD-ERR)<sup class="footnote-reference"><a href="#1">2</a></sup> 的建议, 应该为错误类型实现 <code>Debug</code> / <code>Error</code> 和 <code>Display</code> 等 trait. 本文使用库 <code>thiserror</code><sup class="footnote-reference"><a href="#3">3</a></sup> 来自动完成这一步骤.</p>
<h2 id="从解决方案构造关卡"><a class="header" href="#从解决方案构造关卡">从解决方案构造关卡</a></h2>
<p>从解决方案构造关卡可以分为以下几个部分:</p>
<ol>
<li>
<p><strong>确定地图尺寸</strong>: 地图的尺寸等于玩家移动范围加上 1, 以包含外墙.</p>
</li>
<li>
<p><strong>模拟玩家移动</strong>: 模拟玩家的移动, 并记录三组数据, 分别是: <em>当前箱子位置</em>和箱子初始位置.</p>
<p>玩家只能在地板上移动, 因此将玩家移动到的位置设为地板.
若玩家推动了箱子, 且该箱子移动前的位置不再<em>当前箱子位置</em>中, 添加到箱子位置中.
箱子当前位置在模拟结束后, <em>当前箱子位置</em>即最终箱子位置. 若解决方案正确, 那么最终箱子位置与目标位置相同.</p>
</li>
<li>
<p><strong>添加墙壁</strong>: 在地板周围添加墙壁, 以形成完整的关卡结构.</p>
</li>
<li>
<p><strong>验证解决方案</strong>: 在构造的关卡里验证解决方案的有效性. 若验证失败, 则表示解决方案不正确.</p>
</li>
</ol>
<pre><code class="language-rs">impl Map {
    pub fn from_actions(actions: &amp;Actions) -&gt; Result&lt;Self, ParseMapError&gt; {
        let mut min_position = Vector2::&lt;i32&gt;::zeros();
        let mut max_position = Vector2::&lt;i32&gt;::zeros();

        // Calculate the dimensions of the player's movement range
        let mut player_position = Vector2::zeros();
        for action in &amp;**actions {
            player_position += &amp;action.direction().into();
            min_position = min_position.zip_map(&amp;player_position, |a, b| a.min(b));
            max_position = max_position.zip_map(&amp;player_position, |a, b| a.max(b));
        }

        // Reserve space for walls
        min_position -= Vector2::new(1, 1);
        max_position += Vector2::new(1, 1);

        if min_position.x &lt; 0 {
            player_position.x = min_position.x.abs();
        }
        if min_position.y &lt; 0 {
            player_position.y = min_position.y.abs();
        }

        let dimensions = min_position.abs() + max_position.abs() + Vector2::new(1, 1);
        let mut instance = Map::with_dimensions(dimensions);

        // The initial position of boxes are the box positions, and the final position
        // of boxes are the goal positions
        let mut initial_box_positions = HashSet::new();
        let mut final_box_positions = HashSet::new();

        let mut final_player_position = player_position;
        for action in &amp;**actions {
            instance[final_player_position] = Tiles::Floor;
            final_player_position += &amp;action.direction().into();
            if action.is_push() {
                // The player pushed the box when moving, which means there is a box at the
                // player's current location
                if !final_box_positions.contains(&amp;final_player_position) {
                    final_box_positions.insert(final_player_position);
                    initial_box_positions.insert(final_player_position);
                }
                final_box_positions.remove(&amp;final_player_position);
                final_box_positions.insert(final_player_position + &amp;action.direction().into());
            }
        }
        instance[final_player_position] = Tiles::Floor;

        let box_positions = initial_box_positions;
        let goal_positions = final_box_positions;
        if box_positions.is_empty() {
            return Err(ParseMapError::NoBoxOrGoal);
        }

        instance[player_position].insert(Tiles::Player);
        for box_position in &amp;box_positions {
            instance[*box_position].insert(Tiles::Box);
        }
        for goal_position in &amp;goal_positions {
            instance[*goal_position].insert(Tiles::Goal);
        }

        instance.add_walls_around_floors();

        instance.player_position = player_position;
        instance.box_positions = box_positions;
        instance.goal_positions = goal_positions;

        // Verify solution
        let mut level = Level::from_map(instance.clone());
        for action in &amp;**actions {
            level
                .do_move(action.direction())
                .map_err(|_| ParseMapError::InvalidActions)?;
        }

        Ok(instance)
    }
}
</code></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">2</sup>
<p><a href="https://rust-lang.github.io/api-guidelines/interoperability.html#error-types-are-meaningful-and-well-behaved-c-good-err">https://rust-lang.github.io/api-guidelines/interoperability.html#error-types-are-meaningful-and-well-behaved-c-good-err</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">1</sup>
<p><a href="https://doc.rust-lang.org/std/io/struct.BufReader.html">https://doc.rust-lang.org/std/io/struct.BufReader.html</a></p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p><a href="https://docs.rs/thiserror/latest/thiserror/">https://docs.rs/thiserror/latest/thiserror/</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="标准化"><a class="header" href="#标准化">标准化</a></h1>
<p>有些关卡为了美观会在原关卡的基础上添加一些装饰, 这些装饰性的元素在本质上并<strong>不影响关卡的解法</strong>.<br />
标准化的目的是移除这些与求解<strong>无关或冗余</strong>的元素.</p>
<p>理想状态下, 任何具有相同步数最优解的关卡都可以被标准化为同一个关卡. 理论上可以先对关卡解析自动求解, 获得最优解决方案后再<a href="level/parse_level.html#%E4%BB%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9E%84%E9%80%A0%E5%85%B3%E5%8D%A1">从解决方案构造关卡</a>来得到标准化后的关卡.<br />
但对于 NP 难<sup class="footnote-reference"><a href="#1">1</a></sup>的推箱子问题来说, 自动求解最优解决方案通常是耗时且困难的, 因此还需要一种不依赖于关卡解决方案的高效(多项式时间内得出结果)标准化方法. 尽管该方法得到的标准化结果并不完美.</p>
<p>关卡的标准化可以分为以下几个步骤:</p>
<ol>
<li>
<p>将不可移动的箱子变为墙.</p>
<p>箱子可能默认就处于死锁状态, 可以当作墙体处理.</p>
</li>
<li>
<p>将无需使用的地板变为墙.</p>
<p>如果一个地板被三面墙包围, 属于死胡同, 可以当作墙体处理.</p>
</li>
<li>
<p>移除无法到达的墙.</p>
<p>部分墙无法与玩家产生交互, 因此移除这部分墙不影响关卡的解决方案.</p>
</li>
<li>
<p>统一外墙形式.</p>
<p>外墙有不同的包围类型, 如:</p>
<pre><code class="language-txt"> ###
#@$.#
 ###

#####
#@$.#
#####
</code></pre>
<p>应该统一为其中一种类型, 通常使用下面的类型.</p>
</li>
<li>
<p>移除无法到达的箱子.</p>
<p>部分箱子无法与玩家产生交互, 因此移除这部分箱子不影响关卡的解决方案.</p>
</li>
<li>
<p>收紧地图尺寸.</p>
<p>地图中的元素被删除可能导致地图尺寸缩小.</p>
</li>
<li>
<p>对旋转和翻转标准化.</p>
<p>将经过不同旋转和翻转的关卡标准化为同一个关卡.
一个简单的方法是计算不同旋转和翻转后地图的哈希值，选择哈希值最小的版本.</p>
</li>
<li>
<p>玩家初始位置标准化. <strong>(注意: 可能移动玩家位置, 进而改变关卡的解决方案)</strong></p>
<p>需要对先对玩家的位置进行标准化. 因为即使玩家位置不一样, 但都在同一个区域也可以转变为同一个关卡.
一个简单的玩家位置标准化方法是将玩家的位置设为玩家可达区域的位置中 Y 坐标最小, 其次 X 坐标最小的位置.</p>
</li>
</ol>
<h2 id="激进的标准化"><a class="header" href="#激进的标准化">激进的标准化</a></h2>
<p>激进的标准化可能改变关卡的解. 以最简单的关卡为例:</p>
<pre><code class="language-txt">#####
#@$.#
#####
</code></pre>
<p>因为玩家开始的位置三面有墙, 位于死胡同, 只能向右移动. 得到结果:</p>
<pre><code class="language-txt">#####
# @*#
#####
</code></pre>
<p>玩家左侧死胡同属于无用的区域, 使用墙体填充. 玩家右侧位于目标上的箱子处于死锁状态, 属于无用的箱子和目标, 使用墙体填充. 最后移除多余的墙体得到激进的标准化结果:</p>
<pre><code class="language-txt">###
#@#
###
</code></pre>
<p>这是一个最简单的非标准关卡, 因为其没有箱子和目标, 解为空.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.sciencedirect.com/science/article/pii/S0925772199000176">https://www.sciencedirect.com/science/article/pii/S0925772199000176</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="求解器solver"><a class="header" href="#求解器solver">求解器(Solver)</a></h1>
<p>顾名思义, 求解器是用于自动求解推箱子关卡的程序.</p>
<p>阅读本文前, 读者需要自行了解搜索算法的工作原理. 因为相比推箱子求解, 一般的寻路算法更适合读者理解搜索算法.</p>
<h2 id="图graph"><a class="header" href="#图graph">图(Graph)</a></h2>
<p>以下面关卡为例:</p>
<pre><code class="language-txt">######
# @$.#
######
</code></pre>
<p>该关卡存在三种状态, 分别为:</p>
<pre><code class="language-txt">A:        B:        C:
######    ######    ######
# @$.#    #@ $.#    #  @*#
######    ######    ######
</code></pre>
<p>为了更直观地展示这些状态之间的转换关系, 可以用图的形式表示为:</p>
<pre class="mermaid">graph TD
    A--&gt;|l| B
    B--&gt;|r| A
    A--&gt;|R| C
    C--&gt;|L| A
</pre>
<p>这是一个以状态(State)为节点(Vertex), 动作(Action)为边(Edge)的有向图(Directed graph).<br />
其中 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 为初始状态(Initial state, IS), <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 为目标状态(Goal state, GS), <code>l</code> 和 <code>r</code> 分别表示玩家向左和向右移动, <code>R</code> 和 <code>L</code> 分别表示玩家向右推动和向左拉动.</p>
<p>理论上, 状态 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 还可以衍生出更多子状态, 但因为其是目标状态, 搜索算法无需继续搜索, 因此这里不再展开.</p>
<p>求解器的工作是进行空间状态搜索<sup class="footnote-reference"><a href="#1">1</a></sup>, 即首先根据初始状态生成推箱子关卡的图, 然后在这个图中寻找从初始状态到目标状态的路径. 以上图为例, 就是寻找从状态 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 到状态 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 的路径, 即 <code>R</code>.</p>
<p>寻路算法是在<strong>路径点</strong>组成的图中寻找一条从<strong>初始位置</strong>到<strong>目标位置</strong>的路径.<br />
求解器则是在<strong>状态</strong>组成的图中寻找一条从<strong>初始状态</strong>到<strong>目标状态</strong>的路径, 即移动箱子的顺序.</p>
<p>下面将详细探讨如何利用搜索算法来找到这条路径.</p>
<h2 id="搜索算法"><a class="header" href="#搜索算法">搜索算法</a></h2>
<ul>
<li>
<p>广度优先搜索算法(Breadth-first search, BFS)<sup class="footnote-reference"><a href="#2">2</a></sup>.</p>
</li>
<li>
<p>A* 搜索算法<sup class="footnote-reference"><a href="#3">3</a></sup></p>
<p>A* 与 BFS 在最坏情况下的时间复杂度均为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. 但 A* 算法是一种最佳优先搜索(Best-first search)算法, 会优先探索最有希望的节点.</p>
</li>
<li>
<p>IDA* 搜索算法<sup class="footnote-reference"><a href="#4">4</a></sup></p>
<p>相比空间复杂度为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的 A* 算法, IDA* 算法的空间复杂度为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span>.</p>
</li>
<li>
<p>FESS 搜索算法<sup class="footnote-reference"><a href="#5">5</a></sup></p>
<p>A* 和 IDA* 算法只通过单个启发式函数值值来选择下一个探索的节点.<br />
虽然可以通过计算出多个启发式函数值, 将它们融合为单个启发式函数值, 以同时利用多种启发式函数, 但由于多个启发式函数值被融合为了一个, 因此无法区分单个启发式函数值的变化趋势. FESS 算法则在这方面做出了改进. 该论文的第一作者 Yaron Shoham 还将该算法应用在了求解器 Festival<sup class="footnote-reference"><a href="#6">6</a></sup> 上, 并取得了极佳的效果<sup class="footnote-reference"><a href="#7">7</a></sup>.</p>
</li>
</ul>
<p>本文不会进一步探讨 FESS 算法, 感兴趣的读者可以阅读相关论文.</p>
<p>BSF/A*/IDA* 算法均可以用于搜索最短路径, 即最佳解决方案.<br />
由于推箱子问题是PSPACE完全(PSPACE-complete)的, 使用 BSF 这种非启发式算法是难以搜索到解决方案的.<br />
而 IDA* 算法则是基于 A* 算法的改进, 所以本文将描述如何创建一个基于 A* 搜索算法的求解器.</p>
<h2 id="表示状态"><a class="header" href="#表示状态">表示状态</a></h2>
<p>状态只需要包含了玩家的位置和箱子的位置, 因为玩家和箱子是关卡中可移动对象. 保存它们的位置足以描述整个关卡的状态.<br />
其他元素, 如墙壁/目标位置等是静态的，它们的位置不会随状态的改变而改变, 因此只需要从关卡的初始状态中获取它们的位置.</p>
<pre><code class="language-rs">pub struct State {
    pub player_position: Vector2&lt;i32&gt;,
    pub box_positions: HashSet&lt;Vector2&lt;i32&gt;&gt;,
}
</code></pre>
<p>实现从 <code>Map</code> 到 <code>State</code> 的转换:</p>
<pre><code class="language-rs">impl From&lt;Map&gt; for State {
    fn from(map: Map) -&gt; Self {
        Self {
            player_position: map.player_position(),
            box_positions: map.box_positions().clone(),
        }
    }
}
</code></pre>
<p>这样就可以将地图转为初始状态, 然后作为搜索起点开始搜索.</p>
<pre class="mermaid">flowchart LR
    A{是否有\n未探索的状态} --&gt;|是| B
    A --&gt;|否| H[返回无解]
    B[取出优先级\n最高的未探索状态] --&gt; C{是目标状态?}
    C --&gt;|是| D[返回解决方案]
    C --&gt;|否| E[&quot;生成其子状态(邻域)&quot;]
    E --&gt; F{是否已访问过?}
    F --&gt;|是| E
    F --&gt;|否| G[将子状态加入 heap]
    G --&gt; A
</pre>
<p>创建一个新的结构体用于存储到状态的代价和启发式函数值:</p>
<pre><code class="language-rs">struct Node {
    state: State,
    cost: i32,
    heuristic: i32,
    priority: i32,
}
</code></pre>
<p>其中 <code>priority</code> 的值是根据搜索策略而计算的.</p>
<p>对于未探索的状态, 可以利用 <code>BinaryHeap</code> 容器来存储. 因为该容器能够高效地取出最大的元素.</p>
<p>通过重载 <code>Node</code> 的 <code>Ord</code> trait, 可以将状态通过优先级排序.</p>
<pre><code class="language-rs">impl Ord for Node {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        self.priority.cmp(&amp;other.priority).reverse()
    }
}

impl PartialOrd for Node {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        Some(self.cmp(other))
    }
}
</code></pre>
<p>值得注意的是, Rust 中的 <code>BinaryHeap</code> 的实现方式是最大栈(max-heap), 因此 <code>BinaryHeap::pop</code> 函数返回的是容器中最大的元素. 而优先级的值越小表示优先级越高, 因此比较后还需要调用 <code>Ordering::reverse</code> 函数.<br />
这样该便可以从容器中取出优先级最高(即最小)的状态.</p>
<h2 id="标准化玩家位置"><a class="header" href="#标准化玩家位置">标准化玩家位置</a></h2>
<p>玩家的移动会产生大量新的状态, 然而许多状态仅仅是玩家在固定区域内反复移动而未对箱子位置产生任何影响, 这些状态对于求解问题并无实质性贡献. 例如:</p>
<pre><code class="language-txt">#####
#   ###
#  @$.#
#######
</code></pre>
<p>尽管玩家可以在箱子的左侧区域内活动, 但只有当玩家向右推动箱子时, 才能对求解做出贡献.</p>
<p>在移动数优先的搜索策略里, 生成仅移动的状态能确保角色以最短路径移动. 但这也可以通过更高效的最优寻路算法来实现.</p>
<p>因此, 如果玩家只是在一个区域内移动而不推动箱子, 对于推箱子求解是没有意义的. 为了减少这类无用状态的产生, 可以在状态中存储玩家可移动的区域和箱子的位置.</p>
<p>存储玩家可移动区域的一个简单且高效的实现方法是将玩家的位置标准化.<br />
即将玩家移动到一个特殊的位置, 比如设置到可移动区域中最左其次最上的位置. 这样在箱子布局一样的情况下, 玩家标准化位置相同就意味着玩家可达区域相同.</p>
<pre><code class="language-rs">pub fn normalized_area(area: &amp;HashSet&lt;Vector2&lt;i32&gt;&gt;) -&gt; Option&lt;Vector2&lt;i32&gt;&gt; {
    area.iter()
        .min_by(|a, b| a.y.cmp(&amp;b.y).then_with(|| a.x.cmp(&amp;b.x)))
        .copied()
}
</code></pre>
<h2 id="生成邻域"><a class="header" href="#生成邻域">生成邻域</a></h2>
<p>从初始状态开始探索其相邻的节点, 即邻域<sup class="footnote-reference"><a href="#8">8</a></sup>.</p>
<p>通过下面函数来生成当前状态的派生状态, 即相邻的状态:</p>
<pre><code class="language-rs">impl State {
    pub fn successors(&amp;self, solver: &amp;Solver) -&gt; Vec&lt;State&gt; {
        // ... SKIP ...
    }
}
</code></pre>
<p>因为只有推动箱子的状态才有价值, 该函数会尝试在当前状态的基础上生成产生推动而不只是产生移动的状态.</p>
<h2 id="搜索"><a class="header" href="#搜索">搜索</a></h2>
<p>一个只能判断是否有解决方案的简单实现如下:</p>
<pre><code class="language-rs">impl Solver {
    pub fn a_star_search(&amp;self, map: &amp;Map) -&gt; Result&lt;(), SearchError&gt; {
        let mut heap = BinaryHeap::new();
        let mut visited = HashSet::new();

        let state: State = map.clone().into();
        heap.push(Node::new(state, 0, self));

        while let Some(Node { state, cost, .. }) = heap.pop() {
            if state.is_solved(self) {
                return Ok(());
            }
            for successor in state.successors(self) {
                if !visited.insert(successor.normalized_hash(map)) {
                    continue;
                }
                heap.push(Node::new(successor, cost + 1, self));
            }
        }
        Err(SearchError::NoSolution)
    }
    // ... SKIP ...
}
</code></pre>
<p>复杂推箱子关卡的图可能存在环(Loop), 这意味着:</p>
<ol>
<li>需要记录已探索过的节点, 避免进入环中导致死循环.</li>
<li>推箱子关卡的状态可以用图表示, 却无法用树(Tree)表示.</li>
</ol>
<p>已被探索的节点通常会被存储在一个闭集(Closed set)中, 为了通俗易懂, 使用变量名 <code>visited</code> 表示这个闭集.<br />
为了节省内存, <code>visited</code> 中只需要存储已访问状态的哈希值, 因为这些状态将不会再被使用.</p>
<p>复杂推箱子关卡的图非常大, 难以提前生成并存储在内存中. 因此可以在搜索的过程中逐步拓展图.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/State_space_search">https://en.wikipedia.org/wiki/State_space_search</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="https://en.wikipedia.org/wiki/Breadth-first_search">https://en.wikipedia.org/wiki/Breadth-first_search</a></p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p><a href="https://en.wikipedia.org/wiki/A*_search_algorithm">https://en.wikipedia.org/wiki/A*_search_algorithm</a></p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p><a href="https://en.wikipedia.org/wiki/Iterative_deepening_A*">https://en.wikipedia.org/wiki/Iterative_deepening_A*</a></p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p><a href="https://ieeexplore.ieee.org/document/9231929">https://ieeexplore.ieee.org/document/9231929</a></p>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">6</sup>
<p><a href="https://festival-solver.site/">https://festival-solver.site/</a></p>
</div>
<div class="footnote-definition" id="7"><sup class="footnote-definition-label">7</sup>
<p><a href="http://sokobano.de/wiki/index.php?title=Solver_Statistics">http://sokobano.de/wiki/index.php?title=Solver_Statistics</a></p>
</div>
<div class="footnote-definition" id="8"><sup class="footnote-definition-label">8</sup>
<p><a href="https://en.wikipedia.org/wiki/Neighbourhood_(graph_theory)">https://en.wikipedia.org/wiki/Neighbourhood_(graph_theory)</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="搜索策略"><a class="header" href="#搜索策略">搜索策略</a></h1>
<h2 id="什么是最短路径"><a class="header" href="#什么是最短路径">什么是最短路径?</a></h2>
<p>在常见的寻路算法中, <strong>最短</strong>可能是指距离最短, 也可能是指时间最短.<br />
在推箱子中也是如此, 既有移动数最优解决方案, 也有推动数最优解决方案.</p>
<h2 id="策略"><a class="header" href="#策略">策略</a></h2>
<p>推箱子求解器通常有以下策略:</p>
<ul>
<li><code>Fast</code>: A* 算法可以用于搜索最短路径, 但不一定只能搜索最短路径. 通过提高启发式函数的权重可以提高搜索到任何解决方案的效率, 即<strong>速度</strong>.</li>
<li><code>OptimalPush</code>: 搜索<strong>推动数</strong>最少的解决方案.</li>
<li><code>OptimalMove</code>: 搜索<strong>移动数</strong>最少的解决方案.</li>
<li>搜索<strong>推动数</strong>最少其次<strong>移动数</strong>最少的解决方案.</li>
<li>搜索<strong>移动数</strong>最少其次<strong>推动数</strong>最少的解决方案.</li>
</ul>
<h2 id="表示-1"><a class="header" href="#表示-1">表示</a></h2>
<pre><code class="language-rs">pub enum Strategy {
    /// Search for any solution as quickly as possible
    Fast,

    /// Find the push optimal solution
    OptimalPush,

    /// Find the move optimal solution
    OptimalMove,
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="启发式函数heuristic-function"><a class="header" href="#启发式函数heuristic-function">启发式函数(Heuristic function)</a></h1>
<p>启发式函数用于指导搜索算法的搜索方向.</p>
<p>A* 算法的核心是估价函数 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>. 其中:</p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 是某个状态.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 为从初始状态到 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 状态的<strong>实际</strong>代价.</li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 为从 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 状态到目标状态的代价的<strong>估计</strong>代价.</li>
</ul>
<p>搜索最短路径就是指搜索总代价(即 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 的函数值)最小的路径. 以推箱子为例:</p>
<ul>
<li>代价可能指玩家移动数, 也可能指箱子推动数, 这取决于求解器的搜索策略. 因此针对不同的搜索策略, 于代价相关的函数 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> 和 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 的实现不同.</li>
<li>路径就是解决方案.</li>
</ul>
<p>该算法总是能搜索到最优路径, 前提是启发式函数 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 满足容许性(Admissible)<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<h2 id="容许性admissible"><a class="header" href="#容许性admissible">容许性(Admissible)</a></h2>
<p>启发式函数满足容许性, 才能确保结果是最优的. 若函数 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 满足以下条件则满足容许性:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 是从 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 状态到目标状态的<strong>实际</strong>代价.</p>
<p>对于最优路径上的任意状态 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>, 到目标状态的<strong>实际</strong>代价总是为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>. 若 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>, 在搜索 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> 函数值相同的节点时, 一定会跳过最优路径, 进而返回非最优路径.<br />
函数 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 不满足容许性也可能返回最优路径, 因为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 不一定恒成立.</p>
<h2 id="设计的方向"><a class="header" href="#设计的方向">设计的方向</a></h2>
<p>假设 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, 此时函数 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 满足容许性, 但不再能启发搜索方向, 该情况下的 A* 算法也被称之为相同代价搜索(Uniform-cost search, UCS), 下一个搜索节点的优先级为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>, 行为与 BFS <strong>类似</strong>. 虽然可以得到最优解, 但无法得到 "启发式" 带来的任何的优化.<br />
理想状态下 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>, 但这<strong>不可能</strong>. 因此函数 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 应该在满足容许性的前提下, 尽可能的接近 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>.</p>
<hr />
<p>对于网格上的寻路算法, 一种启发式函数的实现是计算当前位置和目标位置之间的曼哈顿距离. 相比之下, 推箱子的启发式函数实现并不那么显而易见.<br />
理想状态下, 函数 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 对于任意关卡的任意解决方案 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 应满足以下条件:</p>
<ul>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></li>
<li><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<h2 id="预计算"><a class="header" href="#预计算">预计算</a></h2>
<p>启发式函数计算的适合通常会假设地图上只有一个箱子, 因为这样计算出的结果与箱子的位置无关. 在搜索状态的时候箱子的位置会不断发生改变, 但是启发式函数的值不变.<br />
因此可以提前计启发式函数的值, 供后续搜索时使用.</p>
<h2 id="下界lower-bounds"><a class="header" href="#下界lower-bounds">下界(Lower bounds)</a></h2>
<p>下界是一个箱子到任何目标的最短距离.<br />
根据搜索策略有两种下界:</p>
<ul>
<li>推动下界.</li>
<li>移动下界.</li>
</ul>
<p>其中推动下界可以用于搜索最优移动数解决方案, 反之则不行. 因为推动下界一定小于移动下界.</p>
<p>最简单的推动下界计算方法是计算每个箱子到最近目标的曼哈顿距离<sup class="footnote-reference"><a href="#2">2</a></sup>. 曼哈顿距离也是网格中寻路常用的启发式函数的计算方法.</p>
<p>TODO: 使用二维数组而非 HashMap 来存储下界.</p>
<pre><code class="language-rs">fn manhattan_distance(a: Vector2&lt;i32&gt;, b: Vector2&lt;i32&gt;) -&gt; u32 {
    (a.x - b.x).abs() + (a.y - b.y).abs()
}

let mut lower_bounds = HashMap::new();
for x in 1..self.map.dimensions().x - 1 {
    for y in 1..self.map.dimensions().y - 1 {
        let position = Vector2::new(x, y);
        if self.level[position].intersects(Tiles::Goal) {
            lower_bounds.insert(position, 0);
            continue;
        }
        if !self.map[position].intersects(Tiles::Floor) {
            continue;
        }
        let lower_bound = self
            .map
            .goal_positions()
            .iter()
            .map(|box_position| manhattan_distance(*box_position, &amp;position))
            .min()
            .unwrap(); // 地图上的目标不可能为空 =&gt; 迭代器不可能为空 =&gt; `Iterator::min` 不可能返回 `None`
        lower_bounds.insert(position, lower_bound);
    }
}
lower_bounds
</code></pre>
<p>上面算法的时间复杂度为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>, 其中 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 为地图尺寸, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 为目标数量.<br />
其中函数 <code>manhattan_distance</code> 的时间复杂度为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.</p>
<p>该方法的有点是计算十分快速, 缺点是其忽视了墙体对玩家和箱子的阻碍, 可能严重低估了推动下界.</p>
<h2 id="实现"><a class="header" href="#实现">实现</a></h2>
<p>启发式函数需要计算当前状态到目标状态的下界.<br />
所有箱子所在位置的下界之和.</p>
<pre><code class="language-rs">impl State {
    fn calculate_lower_bound(&amp;self, solver: &amp;Solver) -&gt; usize {
        self.box_positions
            .iter()
            .map(|box_position| solver.lower_bounds()[&amp;box_position])
            .sum()
    }
    // ... SKIP ...
}
</code></pre>
<h2 id="特征"><a class="header" href="#特征">特征</a></h2>
<p>除了通过下界计算得到的启发式函数值, 还有一些特征的值可以附加在启发式函数值上, 在确保启发式函数值保持其容许性的前提下, 优先搜索有相同启发式函数值的状态中选择更接近目标状态的节点.</p>
<h3 id="连接性特征"><a class="header" href="#连接性特征">连接性特征</a></h3>
<p>玩家全部可达区域可能会被箱子分割为多个区域. 这些区域的数量越少意味着玩家可以移动的范围越大.</p>
<p>因为区域是被箱子分割的, 因此只需要检测箱子周围的点所属的区域即可获得独立的区域数.
通过判断箱子在割点上的情况快速判断独立区域的数量.</p>
<p>TODO</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/Admissible_heuristic">https://en.wikipedia.org/wiki/Admissible_heuristic</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="https://simple.wikipedia.org/wiki/Manhattan_distance">https://simple.wikipedia.org/wiki/Manhattan_distance</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="优化"><a class="header" href="#优化">优化</a></h1>
<p>在计算复杂性理论中, 推箱子属于 PSPACE-complete 问题, 是 PSPACE 中最难的一类问题. 推箱子的地图尺寸和箱子数量没有限制. 这类问题目前只能在<strong>超多项式时间</strong>(superpoly-nomial)内解决.<br />
因此没有任何优化的暴力搜索只能解决非常简单(地图尺寸小, 箱子数量少)的关卡, 如果希望解决更复杂的关卡则需要进行优化.</p>
<p>本文所描述的求解器将使用以下优化手段:</p>
<ul>
<li>启发式搜索(Heuristic search): 使用启发式搜索算法, 如 A*.</li>
<li>剪枝(Pruning): 利用<a href="solver/deadlocks.html">死锁</a>检测进行剪枝.</li>
<li>记忆化搜索(Memoization): 防止重复搜索相同节点, 或陷入图里的环.</li>
<li>预处理(Preprocessing): 预计算下界.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="死锁deadlock"><a class="header" href="#死锁deadlock">死锁(Deadlock)</a></h1>
<h2 id="what"><a class="header" href="#what">什么是死锁</a></h2>
<p>推箱子的通关条件是每个箱子都被推至一个目标位置. 但在一些情况下, 箱子永远不能再被推到目标上(比如箱子被推入不是目标的死角), 导致无法通关. 这种情况称之为死锁.</p>
<h2 id="why"><a class="header" href="#why">为什么要检测死锁</a></h2>
<p>死锁检测可以用于可行性剪枝.<br />
死锁产生后, 该状态及其衍生状态一定无解, 求解器将浪费大量的资源去搜索一定无解的状态. 因此需要对死锁进行检测, 从而跳过这些无意义的搜索.</p>
<h2 id="when"><a class="header" href="#when">何时检测死锁</a></h2>
<p>死锁按照箱子和玩家位置的关系可以分为三类:</p>
<ol>
<li>与箱子和玩家位置无关的.</li>
<li>与箱子位置有关和玩家位置无关的.</li>
<li>与箱子和玩家位置有关的.</li>
</ol>
<p>分别为:</p>
<ol>
<li>
<p><strong>静态死锁</strong>: 这种死锁与箱子和玩家的位置无关, 可以在只知道关卡地形和目标位置的情况下进行计算.<br />
标位置是静态的, 而关卡地形可能发生变化. 比如当箱子被推到目标后死锁了, 此时可以将死锁的箱子视为不可移动的墙, 关卡地形发生变化, 需要重新计算.<br />
因为地形变化只能增加墙体, 使死区变多, 所以即使不重新计算也不会产生错误, 但会使静态死锁检测不全面.</p>
</li>
<li>
<p><strong>冻结死锁(freeze deadlocks)</strong>: 这种死锁产生的原因是箱子和墙或箱子之间的相互阻碍导致多个箱子同时死锁.<br />
这类死锁的检测时机是箱子推动后.</p>
</li>
<li>
<p>包括<strong>畜栏死锁(corral deadlocks)</strong>/<strong>闭对角死锁(closed diagonal deadlocks)</strong>: FIXME 这类死锁和冻结死锁的区别是前者只要在箱子推动后变成了一定的模式就会产生, 而后者是否产生死锁还需要看玩家在箱子推动后的位置, 即箱子推动方向.</p>
<p>畜栏死锁是一种更为高级的冻结死锁, 因为即使在畜栏死锁后, 箱子仍然可以被推动, 但最终一定会形成冻结死锁.<br />
畜栏死锁的检测时机是箱子推动后, 有玩家不可达的区域面积减小. 这意味着玩家可能无法再回到该不可达区域, 导致区域周边的箱子的移动自由度减少.</p>
</li>
</ol>
<p>TODO: 利用图片直观的展示各类死锁</p>
<h2 id="how"><a class="header" href="#how">如何检测死锁</a></h2>
<h3 id="静态死锁"><a class="header" href="#静态死锁">静态死锁</a></h3>
<p>将箱子放置在目标位置, 然后拉动箱子到所有可能位置. 箱子到达的区域内的箱子一定能被推动到目标, 而箱子不可达区域一定无法被推动到目标, 即死区.</p>
<h3 id="冻结死锁"><a class="header" href="#冻结死锁">冻结死锁</a></h3>
<p>一个箱子只能在垂直和水平方向上移动, 若箱子的两个方向都被箱子遮挡(即上或下被遮挡, 且左或右被遮挡), 则该箱子处于冻结死锁.</p>
<p>能遮挡箱子的元素有两个:</p>
<ol>
<li>墙体.</li>
<li>其他箱子: 需递归的判断该箱子是否被冻结死锁.</li>
</ol>
<pre><code class="language-rs">pub fn is_freeze_deadlock(
    map: &amp;Map,
    box_position: Vector2&lt;i32&gt;,
    box_positions: &amp;HashSet&lt;Vector2&lt;i32&gt;&gt;,
    visited: &amp;mut HashSet&lt;Vector2&lt;i32&gt;&gt;,
) -&gt; bool {
    debug_assert!(box_positions.contains(&amp;box_position));

    if !visited.insert(box_position) {
        return true;
    }

    for direction in [
        Direction::Up,
        Direction::Down,
        Direction::Left,
        Direction::Right,
    ]
    .chunks(2)
    {
        let neighbors = [
            box_position + &amp;direction[0].into(),
            box_position + &amp;direction[1].into(),
        ];

        // Check if any immovable walls on the axis.
        if map[neighbors[0]].intersects(Tiles::Wall) || map[neighbors[1]].intersects(Tiles::Wall) {
            continue;
        }

        // Check if any immovable boxes on the axis.
        if (box_positions.contains(&amp;neighbors[0])
            &amp;&amp; is_freeze_deadlock(map, neighbors[0], box_positions, visited))
            || (box_positions.contains(&amp;neighbors[1])
                &amp;&amp; is_freeze_deadlock(map, neighbors[1], box_positions, visited))
        {
            continue;
        }

        return false;
    }
    true
}
</code></pre>
<h2 id="参考-1"><a class="header" href="#参考-1">参考</a></h2>
<ul>
<li><a href="http://sokobano.de/wiki/index.php?title=Deadlocks">http://sokobano.de/wiki/index.php?title=Deadlocks</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="资源"><a class="header" href="#资源">资源</a></h1>
<ul>
<li><a href="http://sokobano.de/wiki/">http://sokobano.de/wiki/</a>: 推箱子 Wiki, 德国.</li>
<li><a href="https://sourceforge.net/projects/sokobanyasc/">https://sourceforge.net/projects/sokobanyasc/</a> 推箱子软件 SokobanYASC.</li>
<li><a href="https://www.sokoban-online.de/">https://www.sokoban-online.de/</a>: 推箱子软件 JSoko.</li>
<li><a href="https://ygp.orgfree.com/">https://ygp.orgfree.com/</a> 推箱子软件 YSokoban.</li>
<li><a href="https://sokoban.cn/">https://sokoban.cn/</a>: 推箱子平台, 魔方吧推箱子比赛, 中国.</li>
<li><a href="https://sokoban.jp/">https://sokoban.jp/</a> 推箱子官网, 日本.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="术语表"><a class="header" href="#术语表">术语表</a></h1>
<div class="table-wrapper"><table><thead><tr><th>中文</th><th>英文</th></tr></thead><tbody>
<tr><td>求解器</td><td>solver</td></tr>
<tr><td>解决方案/解</td><td>solution</td></tr>
<tr><td>动作</td><td>action</td></tr>
</tbody></table>
</div>

                        <!-- Giscus -->
                        <script src="https://giscus.app/client.js" data-repo="ShenMian/sokoban-tutorial"
                            data-repo-id="R_kgDOLaAVUw" data-category="Comments" data-category-id="DIC_kwDOLaAVU84CeEvG"
                            data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0"
                            data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN"
                            data-loading="lazy" crossorigin="anonymous" async>
                            </script>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
            window.addEventListener('load', function () {
                window.setTimeout(window.print, 100);
            });
        </script>

    </div>
</body>

</html>
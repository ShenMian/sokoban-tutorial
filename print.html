<!DOCTYPE HTML>
<html lang="cn" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sokoban Tutorial</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">介绍</a></li><li class="chapter-item expanded "><a href="level/index.html"><strong aria-hidden="true">1.</strong> 关卡</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="level/representation.html"><strong aria-hidden="true">1.1.</strong> 表示</a></li><li class="chapter-item expanded "><a href="level/run_length_encoding.html"><strong aria-hidden="true">1.2.</strong> 行程编码</a></li><li class="chapter-item expanded "><a href="level/construction.html"><strong aria-hidden="true">1.3.</strong> 构造</a></li><li class="chapter-item expanded "><a href="level/normalization.html"><strong aria-hidden="true">1.4.</strong> 标准化</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 动作</div></li><li class="chapter-item expanded "><a href="solver/index.html"><strong aria-hidden="true">3.</strong> 求解器</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> 优化</div></li></ol></li><li class="chapter-item expanded "><a href="resources.html"><strong aria-hidden="true">4.</strong> 资源</a></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">5.</strong> 术语表</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Sokoban Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ShenMian/sokoban-tutorial" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>本文将描述如何实现一个推箱子游戏 📦, 代码示例使用 Rust 语言 🦀 编写.<br />
推箱子游戏具有以下特点:</p>
<ul>
<li>规则简单. 可以专注于实现功能, 而非理解复杂的游戏规则和机制.</li>
<li>基本功能易于实现.</li>
<li>有具有挑战的高级功能. 比如纯鼠标控制, 逆推等.</li>
<li>有需要深入钻研的求解器, 用于自动求解推箱子关卡.</li>
</ul>
<p>本文将由浅入深的介绍上面功能并提供实现的思路.</p>
<p>本文不会探讨的内容有:</p>
<ul>
<li>推箱子的其他变种. 感兴趣的读者可以自行了解, 可以作为一种拓展.</li>
<li>Rust 语言本身. 本文中出现的算法适用于其他编程语言. 因为示例代码使用了 Rust 语言, 可能会探讨 Rust 实现该算法的细节, 但不会专门介绍 Rust 语言的特性.</li>
<li>游戏引擎.</li>
</ul>
<p>完整的项目代码位于:</p>
<ul>
<li><a href="https://github.com/shenmian/soukoban">ShenMian/soukoban</a>: 推箱子相关算法实现.</li>
<li><a href="https://github.com/shenmian/sokoban-rs">ShenMian/sokoban-rs</a>: 推箱子游戏实现, 使用 <a href="https://github.com/bevyengine/bevy">Bevy</a> 引擎.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关卡"><a class="header" href="#关卡">关卡</a></h1>
<p>推箱子关卡使用最广泛的格式为 XSB, 最初由 XSokoban 所使用. 该格式使用 ASCII 字符来表示地图元素, 并支持注释和附加元数据.<br />
以关卡 <code>Boxworld #1</code> 为例:</p>
<p><img src="level/../assets/boxworld_1.png" alt="Boxworld #1" /></p>
<p>其 XSB 格式关卡的数据如下:</p>
<pre><code class="language-txt">;Level 1
__###___
__#.#___
__#-####
###$-$.#
#.-$@###
####$#__
___#.#__
___###__
Title: Boxworld 1
Author: Thinking Rabbit
</code></pre>
<ul>
<li>第 1 行, 以 <code>;</code> 开头的单行注释.</li>
<li>第 2-9 行, 使用 ASCII 字符表示的地图数据.</li>
<li>第 10-11 行, 包括关卡标题和作者的元数据.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>ASCII 符号</th><th>描述</th></tr></thead><tbody>
<tr><td><code>&lt;SPACE&gt;</code>/<code>-</code>/<code>_</code></td><td>Floor</td></tr>
<tr><td><code>#</code></td><td>Wall</td></tr>
<tr><td><code>$</code></td><td>Box</td></tr>
<tr><td><code>.</code></td><td>Goal</td></tr>
<tr><td><code>@</code></td><td>Player</td></tr>
<tr><td><code>+</code></td><td>Player on goal</td></tr>
<tr><td><code>*</code></td><td>Box on goal</td></tr>
</tbody></table>
</div>
<p>除了上面的元数据, 还有一种用于多行注释的特殊元数据. 内容通过 <code>comment:</code> 和 <code>comment-end:</code> 包裹.</p>
<p>关卡可能通过行程编码压缩, 详情请参见<a href="level/run_length.html">行程编码</a>.</p>
<h2 id="特殊关卡"><a class="header" href="#特殊关卡">特殊关卡</a></h2>
<h3 id="玩家不可达区域存在箱子"><a class="header" href="#玩家不可达区域存在箱子">玩家不可达区域存在箱子</a></h3>
<p><img src="level/../assets/sasquatch_41.png" alt="Sasquatch #41" /></p>
<pre><code class="language-txt">   #####
   #   #
 ###   ########
##  ***    # # #
 #  * *    ## # #####
##  ***   ## # ##   ##
 ###   #### # # #   #
   #   # # # ####$ $###
  ##   ## # ##  $...$ ##
   ##### # ##    .@.  #
        # # #   $...$ ##
         ########$ $###
                #   #
                #####
</code></pre>
<h3 id="存在只有空元素的行"><a class="header" href="#存在只有空元素的行">存在只有空元素的行</a></h3>
<p><img src="level/../assets/steaming_hot.png" alt="&quot;Steaming Hot&quot; by David Buchweitz" /></p>
<pre><code class="language-txt">  #      #
 #   #  #
  # #  #
   # #  #
  #   #  #
 #   #  #
  # #  #
-
##########
#........####
# $$$$$$$#  #
#.$......#  #
# $$$$$$ #  #
#......$+#  #
#$$$$$$$ #  #
#        ####
##########
</code></pre>
<h3 id="无完整外墙"><a class="header" href="#无完整外墙">无完整外墙</a></h3>
<p>部分推箱子程序支持无完整外墙的关卡.<br />
在本文中, 这种关卡属于无效关卡. 但可以通过为其添加外墙的方式来转换为有效关卡.</p>
<p><img src="level/../assets/no_walls_level.png" alt="&quot;No walls&quot; by Rincewind" /></p>
<pre><code class="language-txt">* ** *
  **
**@$.*
  **
* ** *
</code></pre>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="http://sokobano.de/wiki/index.php?title=Level_format">http://sokobano.de/wiki/index.php?title=Level_format</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="表示"><a class="header" href="#表示">表示</a></h1>
<h2 id="表示地图"><a class="header" href="#表示地图">表示地图</a></h2>
<p>地图共包含 5 种元素, 这些元素可能在一个格子内叠加(比如玩家位于目标上).<br />
最小的数据存储单元字节包含 8 个比特, 足以表示 5 种元素. 因此可以使用一个字节的空间来存储单个地图格子, 其中的每个比特表示一种地图元素.<br />
创建用于表示地图元素的比特位:</p>
<pre><code class="language-rs">use bitflags::bitflags;

bitflags! {
    pub struct Tiles: u8 {
        const Floor = 1 &lt;&lt; 0;
        const Wall = 1 &lt;&lt; 1;
        const Box = 1 &lt;&lt; 2;
        const Goal = 1 &lt;&lt; 3;
        const Player = 1 &lt;&lt; 4;
    }
}
</code></pre>
<p>使用一维数组来存储地图数据, 使用二维向量(数学)存储地图尺寸.</p>
<pre><code class="language-rs">use nalgebra::Vector2;

pub struct Map {
    data: Vec&lt;Tiles&gt;,
    dimensions: Vector2&lt;i32&gt;,
    // ... SKIP ...
}
</code></pre>
<p>使用一维数组而非二维数组是因为一维数组更平坦(flatten), 进行部分操作时更简单高效. 如:</p>
<pre><code class="language-rs">impl Map {
    pub fn with_dimensions(dimensions: Vector2&lt;i32&gt;) -&gt; Self {
        Self {
            data: vec![Tiles::empty(); (dimensions.x * dimensions.y) as usize],
            dimensions,
            // ... SKIP ...
        }
    }
    // ... SKIP ...
}
</code></pre>
<p>因为只需要操作一个数组(而非 n 个数组), 进行调整地图尺寸等操作的代码会更简单高效.
而且能确保动态数组的元素是紧密排列的, 根据数据局部性原理, 读取数据的性能通常会更好.</p>
<p>重载下标运算符, 以便后续直接通过二维坐标访问地图元素.</p>
<pre><code class="language-rs">impl Index&lt;Vector2&lt;i32&gt;&gt; for Map {
    type Output = Tiles;
    fn index(&amp;self, position: Vector2&lt;i32&gt;) -&gt; &amp;Tiles {
        &amp;self.data[(position.y * self.dimensions.x + position.x) as usize]
    }
}

impl IndexMut&lt;Vector2&lt;i32&gt;&gt; for Map {
    fn index_mut(&amp;mut self, position: Vector2&lt;i32&gt;) -&gt; &amp;mut Tiles {
        &amp;mut self.data[(position.y * self.dimensions.x + position.x) as usize]
    }
}
</code></pre>
<h2 id="表示关卡"><a class="header" href="#表示关卡">表示关卡</a></h2>
<p>关卡数据可分为三个部分: 地图数据, 元数据和注释. 其中注释可以作为元数据.<br />
元数据是一个键值对的集合, 因此可以使用 HashMap 来存储.
可以使用下面的结构体存储关卡数据:</p>
<pre><code class="language-rs">pub struct Level {
    map: Map,
    metadata: HashMap&lt;String, String&gt;,
    // ... SKIP ...
}
</code></pre>
<p>将地图从关卡中拆分是因为地图涉及大量的关联函数, 如果都放在 <code>Level</code> 里会导致其变得过于庞大.<br />
为了提升代码的可读性和可维护性, 将相关代码拆分到 <code>Map</code> 中, 并将 <code>Level</code> 的 Deref 操作指向 <code>Map</code>. 并通过实现 <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">Deref trait</a>, 使得用户能够透明地引用到 <code>Level</code> 内部的 Map.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="行程编码run-length-encoding"><a class="header" href="#行程编码run-length-encoding">行程编码(Run-length encoding)</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Run-length_encoding">行程编码</a>(run-length encoding, RLE)经常被用于压缩推箱子的关卡和解决方案.</p>
<pre><code class="language-txt">###
#.###
#*$ #
# @ #
#####
</code></pre>
<p>经 RLE 编码后可得:</p>
<pre><code class="language-txt">3#
#.3#
#*$-#
#--@#
5#
</code></pre>
<p>可以看出, 虽然编码后的关卡有更小的体积, 但不再能直观地看出关卡的结构.</p>
<p>RLE 编码后的关卡通常还会使用 <code>|</code> 来分割行, 而非 <code>\n</code>. 使其看上去更加紧凑:</p>
<pre><code class="language-txt">3#|#.3#|#*$-#|#--@#|5#
</code></pre>
<p>只需要对原本的语句进行修改即可提供对 <code>|</code> 分割行的支持:</p>
<pre><code class="language-rs">for line in str.lines() { ... SKIP ... }

for line in str.split(['\n', '|']) { ... SKIP ... }
</code></pre>
<h2 id="编码"><a class="header" href="#编码">编码</a></h2>
<p>下面是一个简单的 RLE 编码函数的实现:</p>
<pre><code class="language-rs">pub fn rle_encode(str: &amp;str) -&gt; Result&lt;String, EncodeRleError&gt; {
    let mut result = String::new();
    let mut chars = str.chars().peekable();
    let mut count = 0;
    while let Some(char) = chars.next() {
        if char.is_numeric() {
            return Err(EncodeRleError::InvalidCharacter(char));
        }
        count += 1;
        if chars.peek() != Some(&amp;char) {
            if count &gt; 1 {
                result.push_str(&amp;count.to_string());
            }
            result.push(char);
            count = 0;
        }
    }
    Ok(result)
}
</code></pre>
<p>该方法不会使用括号包裹重复的相连字串以提高压缩率.</p>
<h2 id="解码"><a class="header" href="#解码">解码</a></h2>
<p>下面是一个 RLE 解码函数的实现:</p>
<pre><code class="language-rs">pub fn rle_decode(str: &amp;str) -&gt; Result&lt;String, DecodeRleError&gt; {
    let mut result = String::new();

    let mut length_string = String::new();
    let mut iter = str.chars();
    while let Some(char) = iter.next() {
        if char.is_ascii_digit() {
            length_string.push(char);
            continue;
        }
        let mut token = String::new();
        if char == '(' {
            let mut nesting_level = 0;
            for char in &amp;mut iter {
                if char == '(' {
                    nesting_level += 1;
                } else if char == ')' {
                    if nesting_level == 0 {
                        break;
                    }
                    nesting_level -= 1;
                }
                token.push(char);
            }
        } else {
            token = char.to_string();
        }
        let length = length_string.parse().unwrap_or(1);
        result += &amp;token.repeat(length);
        length_string.clear();
    }
    if !length_string.is_empty() {
        return Err(DecodeRleError::EndWithDigits(
            length_string.parse().unwrap(),
        ));
    }
    if result.contains('(') {
        return rle_decode(&amp;result);
    }
    Ok(result)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="构建"><a class="header" href="#构建">构建</a></h1>
<h2 id="从字符串构建单个关卡"><a class="header" href="#从字符串构建单个关卡">从字符串构建单个关卡</a></h2>
<p>关卡解析可以分为两部分: 地图解析/元数据和注释解析.</p>
<h3 id="解析关卡数据"><a class="header" href="#解析关卡数据">解析关卡数据</a></h3>
<p>关联函数 <code>Level::from_str</code> 只负责解析元数据和注释, 地图数据的进一步解析则由 <code>Map::from_str</code> 负责.</p>
<pre><code class="language-rs">impl Level {
    pub fn from_str(str: &amp;str) -&gt; Result&lt;Self, ParseLevelError&gt; {
        let mut map_offset = 0;
        let mut map_len = 0;
        let mut metadata = HashMap::new();
        let mut comments = String::new();
        let mut in_block_comment = false;
        for line in str.split_inclusive(['\n', '|']) {
            if map_len == 0 {
                map_offset += line.len();
            }

            let trimmed_line = line.trim();
            if trimmed_line.is_empty() {
                continue;
            }

            // Parse comments
            if in_block_comment {
                if trimmed_line.to_lowercase().starts_with("comment-end") {
                    // Exit block comment
                    in_block_comment = false;
                    continue;
                }
                comments += trimmed_line;
                comments.push('\n');
                continue;
            }
            if let Some(comment) = trimmed_line.strip_prefix(';') {
                comments += comment.trim_start();
                comments.push('\n');
                continue;
            }

            // Parse metadata
            if let Some((key, value)) = trimmed_line.split_once(':') {
                let key = key.trim().to_lowercase();
                let value = value.trim();

                if key == "comment" {
                    if value.is_empty() {
                        // Enter block comment
                        in_block_comment = true;
                    } else {
                        comments += value;
                        comments.push('\n');
                    }
                    continue;
                }

                if metadata.insert(key.clone(), value.to_string()).is_some() {
                    return Err(ParseLevelError::DuplicateMetadata(key));
                }
                continue;
            }

            // Discard line that are not map data (with RLE)
            if !is_xsb_string(trimmed_line) {
                if map_len != 0 {
                    return Err(ParseMapError::InvalidCharacter(
                        trimmed_line
                            .chars()
                            .find(|&amp;c| !is_xsb_symbol_with_rle(c))
                            .unwrap(),
                    )
                    .into());
                }
                continue;
            }

            if map_len == 0 {
                map_offset -= line.len();
            }
            map_len += line.len();
        }
        if !comments.is_empty() {
            debug_assert!(!metadata.contains_key("comments"));
            metadata.insert("comments".to_string(), comments);
        }
        if in_block_comment {
            return Err(ParseLevelError::UnterminatedBlockComment);
        }
        if map_len == 0 {
            return Err(ParseLevelError::NoMap);
        }

        Ok(Self {
            map: Map::from_str(&amp;str[map_offset..map_offset + map_len])?,
            metadata,
            // ... SKIP ...
        })
    }
    // ... SKIP ...
}
</code></pre>
<p>因为只需要对字符串进行解析, 所以参数类型为 <code>&amp;str</code>. 在此过程中, 除了存储解析得到的注释和元数据外, 不涉及额外的动态内存分配.
解析得到的注释将被视作键为 "comments" 的元数据.</p>
<h3 id="解析地图数据"><a class="header" href="#解析地图数据">解析地图数据</a></h3>
<p>解析地图数据可以分为以下几个部分:</p>
<ol>
<li><strong>裁剪空白部分</strong>: 首先, 移除每行右侧的空白字符. 随后, 确定地图左侧的最小缩进量(即每行左侧空白字符的最小数量), 并据此剔除左侧的多余空白.</li>
<li><strong>计算地图尺寸</strong>.</li>
<li><strong>RLE 解码</strong>: 如果地图数据经过 RLE 编码, 进行解码操作.</li>
<li><strong>解析地图数据</strong>: 将转换后的数据写入缓冲区中.</li>
<li><strong>填充地板</strong>. 从玩家位置开始, 以墙为边界, 使用洪水填充算法填充地板.</li>
</ol>
<pre><code class="language-rs">impl Map {
    pub fn from_str(str: &amp;str) -&gt; Result&lt;Self, ParseMapError&gt; {
        debug_assert!(!str.trim().is_empty(), "string is empty");

        // Calculate map dimensions and indentation
        let mut indent = i32::MAX;
        let mut dimensions = Vector2::&lt;i32&gt;::zeros();
        let mut buffer = String::with_capacity(str.len());
        for line in str.split(['\n', '|']) {
            let mut line = line.trim_end().to_string();
            if line.is_empty() {
                continue;
            }
            // If the `line` contains digits, perform RLE decoding
            if line.chars().any(char::is_numeric) {
                line = rle_decode(&amp;line).unwrap();
            }
            dimensions.x = dimensions.x.max(line.len() as i32);
            dimensions.y += 1;
            indent = indent.min(line.chars().take_while(char::is_ascii_whitespace).count() as i32);
            buffer += &amp;(line + "\n");
        }
        dimensions.x -= indent;

        let mut instance = Map::with_dimensions(dimensions);

        // Parse map data
        let mut player_position: Option&lt;Vector2&lt;_&gt;&gt; = None;
        for (y, line) in buffer.lines().enumerate() {
            // Trim map indentation
            let line = &amp;line[indent as usize..];
            for (x, char) in line.chars().enumerate() {
                let position = Vector2::new(x as i32, y as i32);
                instance[position] = match char {
                    ' ' | '-' | '_' =&gt; Tiles::empty(),
                    '#' =&gt; Tiles::Wall,
                    '$' =&gt; {
                        instance.box_positions.insert(position);
                        Tiles::Box
                    }
                    '.' =&gt; {
                        instance.goal_positions.insert(position);
                        Tiles::Goal
                    }
                    '@' =&gt; {
                        if player_position.is_some() {
                            return Err(ParseMapError::MoreThanOnePlayer);
                        }
                        player_position = Some(position);
                        Tiles::Player
                    }
                    '*' =&gt; {
                        instance.box_positions.insert(position);
                        instance.goal_positions.insert(position);
                        Tiles::Box | Tiles::Goal
                    }
                    '+' =&gt; {
                        if player_position.is_some() {
                            return Err(ParseMapError::MoreThanOnePlayer);
                        }
                        player_position = Some(position);
                        instance.goal_positions.insert(position);
                        Tiles::Player | Tiles::Goal
                    }
                    _ =&gt; return Err(ParseMapError::InvalidCharacter(char)),
                };
            }
        }
        if instance.box_positions.len() != instance.goal_positions.len() {
            return Err(ParseMapError::BoxGoalMismatch);
        }
        if instance.box_positions.is_empty() {
            return Err(ParseMapError::NoBoxOrGoal);
        }
        if let Some(player_position) = player_position {
            instance.player_position = player_position;
        } else {
            return Err(ParseMapError::NoPlayer);
        }

        instance.add_floors(instance.player_position);

        Ok(instance)
    }
    // ... SKIP ...
}
</code></pre>
<h3 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h3>
<p>在解析地图数据的过程中, 还需要检查可能发生的错误.<br />
许多错误均可以在解析数据的时候顺带检查, 只会带来很小的额外开销.</p>
<h2 id="从字符串构建多个关卡"><a class="header" href="#从字符串构建多个关卡">从字符串构建多个关卡</a></h2>
<p>多个关卡解析就是将字符串以关卡为单位进行切片, 然后再使用单个关卡解析方法逐个解析.
这种方法将单个关卡的解析和多个关卡之间的分割进行了解耦, 有利于后续实现惰性关卡解析.</p>
<pre><code class="language-rs">impl Map {
    pub fn load(str: &amp;str) -&gt; impl Iterator&lt;Item = Result&lt;Self, ParseLevelError&gt;&gt; + '_ {
        Self::to_groups(str).map(Self::from_str)
    }

    pub fn load_nth(str: &amp;str, id: usize) -&gt; Result&lt;Self, ParseLevelError&gt; {
        let group = Self::to_groups(str).nth(id - 1).unwrap();
        Self::from_str(group)
    }

    fn to_groups(str: &amp;str) -&gt; impl Iterator&lt;Item = &amp;str&gt; + '_ {
        str.split_inclusive(['\n', '|']).filter_map({
            let mut offset = 0;
            let mut len = 0;
            let mut in_block_comment = false;
            let mut has_map_data = false;
            move |line| {
                len += line.len();

                let trimmed_line = line.trim();
                if !in_block_comment &amp;&amp; (trimmed_line.is_empty() || !line.ends_with(['\n', '|'])) {
                    let group = &amp;str[offset..offset + len - 1];
                    offset += len;
                    len = 0;
                    if group.is_empty() || !has_map_data {
                        return None;
                    }
                    has_map_data = false;
                    Some(group)
                } else {
                    if in_block_comment {
                        if trimmed_line.to_lowercase().starts_with("comment-end") {
                            // Exit block comment
                            in_block_comment = false;
                        }
                        return None;
                    }
                    if let Some(value) = trimmed_line.to_lowercase().strip_prefix("comment:") {
                        if value.trim_start().is_empty() {
                            // Enter block comment
                            in_block_comment = true;
                        }
                        return None;
                    }
                    if has_map_data || !is_xsb_string(trimmed_line) {
                        return None;
                    }

                    has_map_data = true;

                    None
                }
            }
        })
    }
}
</code></pre>
<p>关联函数 <code>to_groups</code> 接受包含多个关卡的字符串, 返回包含单个关卡的字符串切片的迭代器.</p>
<p>这种实现方式有以下优点:</p>
<ul>
<li>可以支持从大文件中流式读取关卡, 需要稍加修改以支持 <a href="https://doc.rust-lang.org/std/io/struct.BufReader.html">BufReader</a>.</li>
<li>读取第 n 个关卡. 跳过前 n-1 个关卡, 只对第 n 个关卡的数据进行解析.</li>
</ul>
<h2 id="从解决方案构建关卡"><a class="header" href="#从解决方案构建关卡">从解决方案构建关卡</a></h2>
<p>解析地图数据可以分为以下几个部分:</p>
<ol>
<li>
<p><strong>计算地图尺寸</strong>: 地图的尺寸等于玩家移动范围加上 1, 以包含外墙.</p>
</li>
<li>
<p><strong>模拟玩家移动</strong>: 记录三组数据, 分别是: <em>当前箱子位置</em>和箱子初始位置.</p>
<p>玩家移动到的位置设为地板.
若玩家推动了箱子, 且该箱子移动前的位置不再<em>当前箱子位置</em>中, 添加到箱子位置中.
箱子当前位置在模拟结束后, <em>当前箱子位置</em>即最终箱子位置. 若解决方案正确, 那么最终箱子位置与目标位置相同.</p>
</li>
<li>
<p><strong>在地板周围添加墙壁</strong>: 在地板周围添加墙壁, 形成完整的关卡结构.</p>
</li>
<li>
<p><strong>验证解决方案</strong>: 在构建的关卡里验证解决方案. 若验证不通过, 则表示解决方案不正确.</p>
</li>
</ol>
<pre><code class="language-rs">impl Map {
    pub fn from_actions(actions: &amp;Actions) -&gt; Result&lt;Self, ParseMapError&gt; {
        let mut min_position = Vector2::&lt;i32&gt;::zeros();
        let mut max_position = Vector2::&lt;i32&gt;::zeros();

        // Calculate the dimensions of the player's movement range
        let mut player_position = Vector2::zeros();
        for action in &amp;**actions {
            player_position += &amp;action.direction().into();
            min_position = min_position.zip_map(&amp;player_position, |a, b| a.min(b));
            max_position = max_position.zip_map(&amp;player_position, |a, b| a.max(b));
        }

        // Reserve space for walls
        min_position -= Vector2::new(1, 1);
        max_position += Vector2::new(1, 1);

        if min_position.x &lt; 0 {
            player_position.x = min_position.x.abs();
        }
        if min_position.y &lt; 0 {
            player_position.y = min_position.y.abs();
        }

        let dimensions = min_position.abs() + max_position.abs() + Vector2::new(1, 1);
        let mut instance = Map::with_dimensions(dimensions);

        // The initial position of boxes are the box positions, and the final position
        // of boxes are the goal positions
        let mut initial_box_positions = HashSet::new();
        let mut final_box_positions = HashSet::new();

        let mut final_player_position = player_position;
        for action in &amp;**actions {
            instance[final_player_position] = Tiles::Floor;
            final_player_position += &amp;action.direction().into();
            if action.is_push() {
                // The player pushed the box when moving, which means there is a box at the
                // player's current location
                if !final_box_positions.contains(&amp;final_player_position) {
                    final_box_positions.insert(final_player_position);
                    initial_box_positions.insert(final_player_position);
                }
                final_box_positions.remove(&amp;final_player_position);
                final_box_positions.insert(final_player_position + &amp;action.direction().into());
            }
        }
        instance[final_player_position] = Tiles::Floor;

        let box_positions = initial_box_positions;
        let goal_positions = final_box_positions;
        if box_positions.is_empty() {
            return Err(ParseMapError::NoBoxOrGoal);
        }

        instance[player_position].insert(Tiles::Player);
        for box_position in &amp;box_positions {
            instance[*box_position].insert(Tiles::Box);
        }
        for goal_position in &amp;goal_positions {
            instance[*goal_position].insert(Tiles::Goal);
        }

        instance.add_walls_around_floors();

        instance.player_position = player_position;
        instance.box_positions = box_positions;
        instance.goal_positions = goal_positions;

        // Verify solution
        let mut level = Level::from_map(instance.clone());
        for action in &amp;**actions {
            level
                .do_move(action.direction())
                .map_err(|_| ParseMapError::InvalidActions)?;
        }

        Ok(instance)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标准化"><a class="header" href="#标准化">标准化</a></h1>
<p>有些关卡为了美观会在原关卡的基础上添加一些装饰, 这些装饰性的元素在本质上并不影响关卡的解法.<br />
标准化的目的是移除这些与求解无关或冗余的元素.</p>
<p>理想状态下, 任何具有相同步数最优解的关卡都可以被标准化为同一个关卡. 理论上可以先对关卡解析自动求解, 获得最优解决方案后再<a href="level/parse_level.html#%E4%BB%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9E%84%E5%BB%BA%E5%85%B3%E5%8D%A1">从解决方案构建关卡</a>来得到标准化后的关卡.<br />
但对于 NP 难的推箱子问题来说, 自动求解最优解决方案通常是耗时且困难的, 因此还需要一种不依赖于关卡解决方案的快速标准化方法. 尽管该方法得到的标准化结果并不完美.</p>
<p>关卡的标准化可以分为以下几个步骤:</p>
<ol>
<li>
<p>将不可移动的箱子变为墙.</p>
<p>箱子可能默认就处于死锁状态, 可以当作墙体处理.</p>
</li>
<li>
<p>将无需使用的地板变为墙.</p>
<p>如果一个地板被三面墙包围, 属于死胡同, 可以当作墙体处理.</p>
</li>
<li>
<p>移除无法到达的墙.</p>
<p>部分墙无法与玩家产生交互, 因此移除这部分墙不影响关卡的解决方案.</p>
</li>
<li>
<p>标准化外墙.</p>
<p>外墙有不同的包围类型, 如:</p>
<pre><code class="language-txt"> ###
#@$.#
 ###

#####
#@$.#
#####
</code></pre>
<p>应该统一为其中一种类型, 通常使用下面的类型.</p>
</li>
<li>
<p>移除无法到达的箱子.</p>
<p>部分箱子无法与玩家产生交互, 因此移除这部分箱子不影响关卡的解决方案.</p>
</li>
<li>
<p>收紧地图尺寸.</p>
<p>地图中的元素被删除可能导致地图尺寸缩小.</p>
</li>
<li>
<p>对旋转和翻转标准化.</p>
<p>将经过不同旋转和翻转的关卡标准化为同一个关卡.
一个简单的方法是计算不同旋转和翻转后地图的哈希值，选择哈希值最小的版本.</p>
</li>
<li>
<p>玩家初始位置标准化. <strong>(注意: 可能移动玩家位置, 进而改变关卡的解决方案)</strong></p>
<p>需要对先对玩家的位置进行标准化. 因为即使玩家位置不一样, 但都在同一个区域也可以转变为同一个关卡.
一个简单的玩家位置标准化方法是将玩家的位置设为玩家可达区域的位置中 Y 坐标最小, 其次 X 坐标最小的位置.</p>
</li>
</ol>
<h2 id="激进的标准化"><a class="header" href="#激进的标准化">激进的标准化</a></h2>
<p>激进的标准化可能改变关卡的解.
以最简单的关卡为例:</p>
<pre><code class="language-txt">#####
#@$.#
#####
</code></pre>
<p>因为玩家开始的位置三面有墙, 位于死胡同, 只能向右移动. 得到结果:</p>
<pre><code class="language-txt">#####
# @*#
#####
</code></pre>
<p>玩家左侧死胡同属于无用的区域, 使用墙体填充. 玩家右侧位于目标上的箱子处于死锁状态, 属于无用的箱子和目标, 使用墙体填充. 最后移除多余的墙体得到激进的标准化结果:</p>
<pre><code class="language-txt">###
#@#
###
</code></pre>
<p>这是一个最简单的非标准关卡, 因为其没有箱子和目标, 解为空.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="求解器solver"><a class="header" href="#求解器solver">求解器(Solver)</a></h1>
<p>顾名思义, 求解器是用于自动求解推箱子关卡的程序.</p>
<p>寻路算法是在<strong>路径点</strong>组成的图中寻找一条从<strong>初始位置</strong>到<strong>最终位置</strong>的路径.<br />
求解器则是在<strong>状态</strong>组成的图中寻找一条从<strong>初始状态</strong>到<strong>最终状态</strong>的路径, 即移动箱子的顺序.</p>
<h2 id="搜索算法"><a class="header" href="#搜索算法">搜索算法</a></h2>
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* 搜索算法</a>.</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Iterative_deepening_A*">IDA* 搜索算法</a>.</p>
</li>
<li>
<p><a href="https://ieeexplore.ieee.org/document/9231929">FESS 搜索算法</a>: 该算法被知名推箱子求解器 <a href="https://festival-solver.site/">Festival</a> 所使用.</p>
<p>A* 和 IDA* 只通过单个启发式函数值值来选择下一个探索的节点.<br />
可以通过计算出多个启发式函数值, 将它们融合为单个启发式函数值, 以同时利用多种启发式函数.
这种方法简单有效, 但由于多个启发式函数值被融合为了一个, 因此无法区分单个启发式函数值的变化趋势.</p>
</li>
</ul>
<p>本文将描述如何创建一个基于 <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* 搜索算法</a>的求解器.</p>
<h2 id="表示状态"><a class="header" href="#表示状态">表示状态</a></h2>
<p>顾名思义, 状态用于表示关卡的状态.</p>
<pre><code class="language-rs">pub struct State {
    pub player_position: Vector2&lt;i32&gt;,
    pub box_positions: HashSet&lt;Vector2&lt;i32&gt;&gt;,
}
</code></pre>
<p>可以看出状态仅包含了玩家的位置和箱子的位置, 因为玩家和箱子是关卡中可移动对象. 保存它们的位置足以描述整个关卡的状态. 其他元素, 如墙壁/目标位置等是静态的，它们的位置不会改变, 因此只需要从关卡的初始状态中获取它们的位置.</p>
<hr />
<p>TODO: 启发式函数 -&gt; 只关心箱子位置 -&gt; 仅当箱子位置改变时产生新的状态.</p>
<p>状态是图里的节点, 从初始状态开始探索其相邻的节点, 即<a href="https://en.wikipedia.org/wiki/Neighbourhood_(graph_theory)">邻域</a>.</p>
<p>通过下面函数来生成当前状态的派生状态, 即相邻的状态:</p>
<pre><code class="language-rs">impl State {
    pub fn successors(&amp;self, solver: &amp;Solver) -&gt; Vec&lt;State&gt; {
        // ... SKIP ...
    }
}
</code></pre>
<p>通过启发式算法优先探索最接近最终状态的节点.</p>
<p>TODO</p>
<hr />
<h2 id="启发式函数heuristic-function"><a class="header" href="#启发式函数heuristic-function">启发式函数(Heuristic function)</a></h2>
<p>启发式函数用于指导搜索算法的搜索方向.</p>
<hr />
<h2 id="优化器optimizer"><a class="header" href="#优化器optimizer">优化器(Optimizer)</a></h2>
<p>对已知的路径进行<a href="https://en.wikipedia.org/wiki/Local_search_(optimization)">局部搜索</a>, 以寻找更佳的路径.</p>
<p>TODO: 速度优先的求解策略 + 优化器优化 = 快速得到一个不那么差的解决方案.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="资源"><a class="header" href="#资源">资源</a></h1>
<ul>
<li><a href="http://sokobano.de/wiki/">http://sokobano.de/wiki/</a></li>
<li><a href="https://www.sokoban-online.de/">https://www.sokoban-online.de/</a></li>
<li><a href="https://sokoban.cn/">https://sokoban.cn/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="术语表"><a class="header" href="#术语表">术语表</a></h1>
<div class="table-wrapper"><table><thead><tr><th>中文</th><th>英文</th></tr></thead><tbody>
<tr><td>求解器</td><td>solver</td></tr>
<tr><td>解/解决方案</td><td>solution</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
